
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
  
  
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html"></a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16242598828200.html">数据库</a></h1>
			<p class="meta"><time datetime="2021-06-21T15:18:02+08:00" 
			pubdate data-updated="true">2021/06/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#mvcc%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89">MVCC（多版本并发控制）</a>
<ul>
<li><a href="#undo-log%E7%89%88%E6%9C%AC%E9%93%BE-readview">undo log &amp; 版本链 &amp; readview</a></li>
<li><a href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%97%B6%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%EF%BC%9F">快照读时选择哪一个版本？</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8mvcc%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">使用 MVCC 实现隔离级别</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%88%E8%A7%A3%E5%86%B3%E8%84%8F%E8%AF%BB%EF%BC%89">实现可提交读（解决脏读）</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89">实现可重复读（解决不可重复读）</a></li>
<li><a href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%89">间隙锁（解决幻读）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">使用三级封锁实现隔离级别</a></li>
</ul>
</div>
<blockquote>
<p><a href="https://share.mubu.com/doc/1XILE1PgAia">数据库思维导图</a></p>
</blockquote>
<h2><a id="mvcc%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MVCC（多版本并发控制）</h2>
<p>能够在不加锁的情况下，实现<strong>读已提交</strong>和<strong>可重复读</strong>隔离级别，主要针对的是快照读（当前读是悲观锁的一种）</p>
<ul>
<li>快照读：MVCC 的 select 读取的是快照中的数据，不加锁；（也可以通过 for updat 或 lock in share mode 实现加 X S 锁成为当前读）</li>
<li>当前读：MVCC 的 insert、update、delete 读取的是最新的数据，需要加锁。</li>
</ul>
<h3><a id="undo-log%E7%89%88%E6%9C%AC%E9%93%BE-readview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>undo log &amp; 版本链 &amp; readview</h3>
<ul>
<li>持久性通过 <code>redo log</code> 实现</li>
<li>原子性通过 <code>undo log</code> 实现</li>
<li>隔离性通过 <code>MVCC + 锁</code> 实现</li>
</ul>
<p>数据表有一个隐藏的列 <code>trx_id</code> 记录更改它的事务id（自增）；还有一个回滚指针指向上一个快照。<br />
数据库 undo log 就记录着这一行数据的历史版本以及修改每个版本的事务id</p>
<p><img src="media/16242598828200/16243672223518.jpg" alt="" class="mw_img_center" style="width:600px;display: block; clear:both; margin: 0 auto;" /></p>
<p>readview 是一个含有 4 个属性的对象，在生成的时候，会记录当前版本链的一些信息：</p>
<ul>
<li><code>m_ids</code>：当前活跃的（未提交）的事务 id 列表</li>
<li><code>min_trx_id</code>：<code>m_ids</code> 的最小值</li>
<li><code>max_trx_id</code>：生成 readview 时下一个事务应该分配的 id</li>
<li><code>creator_trx_id</code>：生成 readview 的事务 id</li>
</ul>
<blockquote>
<p>max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。假如 1，2，3 这三个事务，之后3 事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，max_trx_id 的值就是 4。<br />
只有在对表中的记录做改动时（INSERT、DELETE、UPDATE）才会为事务分配事务 id，否则在一个只读事务中的事务 id 值都默认为0。</p>
</blockquote>
<h3><a id="%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%97%B6%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快照读时选择哪一个版本？</h3>
<p>当 select 时，会生成 readview，然后根据四个属性从 undo log 依次来查找第一个可读的版本：</p>
<ul>
<li><code>trx_id</code> == <code>creator_trx_id</code>: 说明更改这个版本的事务就是当前查询的事务，可以访问</li>
<li><code>trx_id</code> &lt; <code>min_trx_id</code>: 说明更改这个版本的事务已经不活跃了（已提交），可以访问</li>
<li><code>min_trx_id</code> &lt;= <code>trx_id</code> &lt;= <code>max_trx_id</code>:
<ul>
<li><code>trx_id</code> in <code>m_ids</code>: 说明更改这个版本的事务还未提交，不可以访问</li>
<li><code>trx_id</code> not in <code>m_ids</code>: 说明更改这个版本的事务已经提交了，可以访问</li>
</ul>
</li>
<li><code>trx_id</code> &gt; <code>max_trx_id</code>: 说明更改这个版本的事务是在当前查询的事务之后开启的，不可以访问</li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8mvcc%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 MVCC 实现隔离级别</h3>
<h4><a id="%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%88%E8%A7%A3%E5%86%B3%E8%84%8F%E8%AF%BB%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现可提交读（解决脏读）</h4>
<p>因为没有提交的事务都在 readview 里面记录着，所以无法读取未提交的事务，保证了可提交读；<br />
生成 readview 的时机是每次 select 快照读的时候，所以存在同一个事务里两次 select 生成两个不同的 readview，造成了不可重复读</p>
<h4><a id="%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现可重复读（解决不可重复读）</h4>
<p>把生成 readview 的时机改成启动事务时，整个事务只有一个 readview，保证了同一个事务读取到的版本是相同的。<br />
由于 MVCC 的版本链是行级别的，所以无法解决幻读。</p>
<h4><a id="%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>间隙锁（解决幻读）</h4>
<p>Mysql 的 InnoDB 通过使用 Next-key Locks 解决幻读：一个事务通过索引查找到一个范围后，就锁住这个索引（Record Locks）以及索引之间的间隙（Gap Locks），这样其他事物就不能往这个范围插入数据了。</p>
<p>Next-key Locks 锁定的是一个前开后闭的区间，查找过程中只有访问到的数据才加锁。</p>
<p><img src="media/16242598828200/16243701070756.jpg" alt="" class="mw_img_center" style="width:499px;display: block; clear:both; margin: 0 auto;" /><br />
例如上图的可能的加锁区间是：</p>
<pre><code class="language-plain_text">(-inf, 0]、(-inf, 0]、(0, 5]、(5, 10]、(10, 15]、(15, 25]、(25, inf]
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用三级封锁实现隔离级别</h2>
<p>除了 MVCC + Next-key Locks，还可以使用三级封锁实现隔离级别</p>
<ol>
<li>修改时加 X 锁，直到事务结束（解决丢失修改）</li>
<li>读取时加 S 锁，读取完立即释放（解决一个事务修改时，另一个事务还能读导致的读脏数据，但是一个事务有多次读时，读完一次释放了锁，中间可能有其他事务获取 X 锁进行修改）</li>
<li>读取时加 S 锁，直到事务结束（解决一个事务有多次读时，中间有其他事务进行修改导致的不可重复读）</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16261749989563.html">主从 & 哨兵</a></h1>
			<p class="meta"><time datetime="2021-07-13T19:16:38+08:00" 
			pubdate data-updated="true">2021/07/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%B5%81%E7%A8%8B">流程</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E9%93%BE">主从链</a></li>
<li><a href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F">哨兵模式</a></li>
</ul>
</div>
<h2><a id="%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流程</h2>
<p>单台 Redis 使用的最大内存不应该超过 20G，超过应该换成集群。数据的复制是单向的，只能从主机到从机，主负责写，从负责读。</p>
<ol>
<li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
<h2><a id="%E4%B8%BB%E4%BB%8E%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主从链</h2>
<p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。<br />
<img src="media/16261749989563/16261750837809.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;" /></p>
<h2><a id="%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>哨兵模式</h2>
<p>自动选举老大的模式，是主从模式的升级，更加健壮。<br />
哨兵是一个独立的进程，监视主机是否宕机，主机宕机后自动选取一个从机作为主机，如果主机宕机后再连回来，就只能当作从机。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16261740670297.html">淘汰策略</a></h1>
			<p class="meta"><time datetime="2021-07-13T19:01:07+08:00" 
			pubdate data-updated="true">2021/07/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"></div>
<p>根据是否设置过期时间分为 <code>volatile-</code> 和 <code>allkeys-</code> 两种</p>
<ol>
<li><code>volatile-lru</code>：从已设置过期时间的数据中执行 LRU 淘汰</li>
<li><code>volatile-ttl</code>：从已设置过期时间的数据中挑选将要过期的数据淘汰</li>
<li><code>volatile-random</code>：从已设置过期时间的数据中随机挑选淘汰</li>
<li><code>allkeys-lru</code>：所有的数据执行 LRU 策略</li>
<li><code>allkeys-random</code>：所有的数据随机挑选</li>
<li><code>noeviction</code>：禁止</li>
<li>4.0 新增的两种：<code>volatile-lfu</code>、<code>allkeys-lfu</code></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16261737897880.html">与 MemCached 对比</a></h1>
			<p class="meta"><time datetime="2021-07-13T18:56:29+08:00" 
			pubdate data-updated="true">2021/07/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">数据持久化</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">内存管理机制</a></li>
</ul>
</div>
<h2><a id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据类型</h2>
<p>Memcached 只支持字符串类型</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据持久化</h2>
<p>Memcached 不支持持久化，Redis 支持 AOF 和 RDB 两种策略</p>
<h2><a id="%E5%88%86%E5%B8%83%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分布式</h2>
<p>Memcached 不支持分布式，只能在客户端使用一致性哈希实现分布式</p>
<h2><a id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存管理机制</h2>
<p>Redis 可以把很久不用的 value 交换到磁盘，Memcached 只能在内存中；<br />
Memcached 把内存分割成特定长度的块存储数据，内存利用率不高。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16261704935337.html">Redis 数据结构</a></h1>
			<p class="meta"><time datetime="2021-07-13T18:01:33+08:00" 
			pubdate data-updated="true">2021/07/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#sds">SDS</a></li>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a>
<ul>
<li><a href="#%E7%BB%93%E6%9E%84">结构</a></li>
<li><a href="#rehash">rehash</a></li>
</ul>
</li>
<li><a href="#%E8%B7%B3%E8%B7%83%E8%A1%A8">跳跃表</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8">链表</a></li>
</ul>
</div>
<h2><a id="sds" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SDS</h2>
<p>Redis 构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。<br />
SDS用一个结构体表示，有三个成员：字符串长度、未使用字节的数量、char 数组</p>
<p>好处：</p>
<ol>
<li>可以 O(1) 时间复杂度获取字符串长度</li>
<li>动态扩容，每次修改 SDS，Redis 会自动扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出问题。</li>
<li>空间预分配，空间扩展的时候，会分配额外的未使用空间，减少连续执行字符串增长操作所需的内存重分配次数。（分配策略：SDS长度小于1M时，未分配空间和长度相同，大于1M时，多分配1M空间。）</li>
</ol>
<h2><a id="%E5%AD%97%E5%85%B8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字典</h2>
<h3><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h3>
<p><code>dict</code> 包含两个 hash 表（<code>dictht</code>），以及 <code>rehashidx</code>，方便进行 rehash；<br />
<code>dictht</code> 包含一个 <code>dictEntry</code> 数组，还有哈希表大小 <code>size</code>；<br />
<code>dictEntry</code> 封装了一个 <code>k-v</code>，以及 <code>next</code> 指针，用于拉链法解决哈希冲突。</p>
<h3><a id="rehash" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>rehash</h3>
<p>渐进式 rehash，通过记录 <code>rehashidx</code>，从 0 开始，每执行一次 rehash 递增，在 rehash 期间，每对字典进行添加、删除、查找或更新操作，都会执行一次渐进式 rehash。</p>
<h2><a id="%E8%B7%B3%E8%B7%83%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>跳跃表</h2>
<p>有序集合的底层实现之一。<br />
基于多指针有序链表实现。查找时从上层指针开始查找，找到区间后再到下一层去查找。<br />
<img src="media/16261704935337/16261731677952.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;" /></p>
<p>如何构建？<br />
当原始链表中元素数量足够大，且抽取足够随机的话，我们得到的索引是均匀的。随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引。<br />
在每次新插入元素的时候，尽量让该元素有 1/2 的几率建立一级索引、1/4 的几率建立二级索引、1/8 的几率建立三级索引，以此类推，当建立二级索引的时候，同时也会建立一级索引；当建立三级索引时，同时也会建立一级、二级索引。</p>
<h2><a id="%E9%93%BE%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>链表</h2>
<p>list 的底层实现之一。<br />
链表节点被封装成 <code>listNode</code>，有 <code>prev</code>、<code>next</code>、<code>value</code> 三个成员。<br />
链表节点使用 <code>list</code> 封装，有 <code>head</code>、<code>tail</code>、<code>len</code> 等成员。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16257616669146.html">Redis 线程模型</a></h1>
			<p class="meta"><time datetime="2021-07-09T00:27:46+08:00" 
			pubdate data-updated="true">2021/07/09</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%8D%95%E7%BA%BF%E7%A8%8B">单线程</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li>
</ul>
</div>
<h2><a id="%E5%8D%95%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单线程</h2>
<p>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型，对应的是 Redis 中的文件事件处理器（file event handler），是单线程方式运行的，通过 <strong>IO 多路复用程序</strong>来监听多个<strong>套接字</strong>，将到达的事件传给文件事件<strong>分派器</strong>，分派器根据事件类型调用相应的<strong>事件处理器</strong>。</p>
<p><img src="media/16257616669146/16261748103370.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;" /></p>
<p><strong>为什么不使用多线程？</strong></p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h2><a id="%E5%A4%9A%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多线程</h2>
<p>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈。<br />
Redis 的多线程只是在网络数据的读写这类<strong>耗时操作</strong>上使用了， 执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16257611818305.html">缓存一致性</a></h1>
			<p class="meta"><time datetime="2021-07-09T00:19:41+08:00" 
			pubdate data-updated="true">2021/07/09</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</div>
<blockquote>
<p>保证数据库和缓存的一致性</p>
</blockquote>
<h2><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案</h2>
<p>如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p><strong>旁路缓存模式</strong>：更新 DB，然后直接删除 cache 。如果删除 cache 失败</p>
<ul>
<li>缓存失效时间变短（不推荐，治标不治本） ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li>增加 cache 更新重试机制（常用）： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16251589620596.html">缓存击穿、穿透、雪崩</a></h1>
			<p class="meta"><time datetime="2021-07-02T01:02:42+08:00" 
			pubdate data-updated="true">2021/07/02</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E9%9B%AA%E5%B4%A9">雪崩</a></li>
<li><a href="#%E7%A9%BF%E9%80%8F">穿透</a>
<ul>
<li><a href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a></li>
</ul>
</li>
<li><a href="#%E5%87%BB%E7%A9%BF">击穿</a></li>
</ul>
</div>
<h2><a id="%E9%9B%AA%E5%B4%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>雪崩</h2>
<p>Redis 服务器崩了或者缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p>
<p>解决：</p>
<ul>
<li>针对 Redis 服务不可用的情况：
<ul>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ul>
</li>
<li>针对热点缓存失效的情况：
<ul>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ul>
</li>
</ul>
<h2><a id="%E7%A9%BF%E9%80%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>穿透</h2>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p>
<p>解决：</p>
<ul>
<li>缓存无效 key，但是为了避免缓存大量无效的 key，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</li>
<li>布隆过滤器（把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。）</li>
</ul>
<h3><a id="%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布隆过滤器</h3>
<ol>
<li>
<p>加入</p>
<ul>
<li>使用多个哈希函数对元素值进行计算，得到哈希值</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1</li>
</ul>
</li>
<li>
<p>判断</p>
<ul>
<li>对给定元素再次进行相同的哈希计算</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值**<em>可能在</em><strong>布隆过滤器中，如果存在一个值不为 1，说明该元素</strong><em>一定不在</em>**布隆过滤器中</li>
</ul>
</li>
</ol>
<h2><a id="%E5%87%BB%E7%A9%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>击穿</h2>
<p>大量的并发集中访问一个key，当这个 key 刚好失效了，这时所有的请求全部落在了db，</p>
<p>解决：</p>
<ul>
<li>设置热点数据永远不过期</li>
<li>缓存失效后访问数据库时，加上互斥锁，保证只有一个请求能访问到 db</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16257591932121.html">一致性哈希</a></h1>
			<p class="meta"><time datetime="2021-07-08T23:46:33+08:00" 
			pubdate data-updated="true">2021/07/08</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a>
<ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9">虚拟节点</a></li>
</ul>
</li>
</ul>
</div>
<blockquote>
<p>一致性哈希分布方式，目的是为了克服传统哈希分布在服务器节点数量变化时，大量数据迁移的问题。<br />
例如分布式缓存，客户端不同的对象请求通过 hash 分配到不同的机器，对应的机器就有这些对象的缓存，如果此时增加删除一些节点，请求被分配到其他机器，就可能造成缓存失效。</p>
</blockquote>
<h2><a id="%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原理</h2>
<p>将哈希空间 [0, 2^n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中<strong>顺时针方向第一个大于等于</strong>该哈希值的节点上。</p>
<p>增加或者删除节点时，只需要将它顺时针下一个节点上的数据重新进行分布即可，对于其他节点都没有影响。</p>
<p><img src="https://mweb-zhousc.oss-cn-qingdao.aliyuncs.com/2021/08/15/16257604049552.jpg" alt="" class="mw_img_center" style="width:563px;display: block; clear:both; margin: 0 auto;" /></p>
<h3><a id="%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚拟节点</h3>
<p>问题：新加入的机器只分担了一台机器的负载，其他机器负载并没有减少。<br />
解决：将每台物理机器虚拟为一组虚拟机器，将虚拟机器均匀的放置到 hash 环上，如果需要确定对象的机器，先确定对象的虚拟机器，再由虚拟机器确定到物理机器。 这样，每增加一台机器，就会影响使所有的机器重新 hash，但是需要 hash 的数量没有变，还是 1/n，和不使用虚拟节点一样。</p>
<p><img src="https://mweb-zhousc.oss-cn-qingdao.aliyuncs.com/2021/08/15/16257608140985.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;" /></p>
<blockquote>
<p>新加入的缓存机器 c4 对应一组虚拟节点 c41，c42，c43，加入到 hash 环后，影响的虚拟节点包括 c31，c22，c11（顺时针查找到第一个节点），而这 3 个虚拟节点分别对应机器 c3，c2，c1。即新加入的一台机器，同时影响到原有的 3 台机器。理想情况下，新加入的机器平等地分担了原有机器的负载，这正是虚拟节点带来的好处。而且新加入机器 c4 后，只影响 25%（1/4）对象分配，也就是说，命中率仍然有 75%，这跟没有使用虚拟节点的一致性 hash 算法得到的结果是相同的。的。</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16257578265670.html">分布式事务</a></h1>
			<p class="meta"><time datetime="2021-07-08T23:23:46+08:00" 
			pubdate data-updated="true">2021/07/08</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#2pc">2PC</a>
<ul>
<li><a href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">存在的问题</a></li>
</ul>
</li>
<li><a href="#3pc">3PC</a>
<ul>
<li><a href="#3pc%E6%94%B9%E8%BF%9B%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">3PC 改进了什么？</a></li>
</ul>
</li>
<li><a href="#tcc">TCC</a>
<ul>
<li><a href="#%E4%B8%8E2pc%E5%8C%BA%E5%88%AB%EF%BC%9F">与 2PC 区别？</a></li>
</ul>
</li>
</ul>
</div>
<blockquote>
<p>分布式锁和分布式事务区别：</p>
<ul>
<li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li>
<li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li>
</ul>
</blockquote>
<h2><a id="2pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2PC</h2>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<ul>
<li><strong>询问</strong>：协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</li>
<li><strong>提交/回滚</strong>：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</li>
</ul>
<h3><a id="%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>存在的问题</h3>
<ul>
<li><strong>阻塞</strong>：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作</li>
<li><strong>单点</strong>：协调者一旦宕机，事务无法完成</li>
<li><strong>保守</strong>：任意一个节点失败就会导致整个事务失败，没有完善的容错机制</li>
</ul>
<h2><a id="3pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3PC</h2>
<p>分为 CanCommit，PreCommit 和 doCommit 三个阶段。<br />
<strong>CanCommit</strong>：让各个参与者分析一下事务内容，询问是否可以执行并提交，这一步不执行事务，可能只是获取到 DB 锁<br />
<strong>PreCommit</strong>：让各个参与者开始执行事务或回滚，并记录日志。如果某个参与者一段时间收不到 PreCommit 命令就回滚。<br />
<strong>doCommit</strong>：让各个参与者提交或回滚。如果某个参与者一段时间收不到 doCommit 命令就提交。</p>
<h3><a id="3pc%E6%94%B9%E8%BF%9B%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3PC 改进了什么？</h3>
<ul>
<li>2PC 如果提交阶段一个参与者掉线了，它就不知道其他参与者是是否提交，也就不知道它应该是提交还是回滚，就会阻塞。</li>
<li>3PC 如果预提交阶段一个参与者掉线了，它超时等不到会直接回滚，然后协调者就收不到所有参与者的 ACK，就会在提交阶段让其他参与者也回滚；如果提交阶段一个参与者掉线了，其他参与者收到了指令进行了提交或回滚，但是掉线的参与者超时等待后就会直接提交（它认为其他参与者大概率也会提交，因为 CanCommit 大家都确认过了可以提交才走能到这一步）</li>
<li><strong>其实真正解决的是超时阻塞问题</strong>，3PC 参与者一段时间收不到下一步命令就会回滚或提交，超时后执行的命令能够<strong>最大限度</strong>的保证数据一致性，但不完全保证。2PC 和 3PC 某些情况下都会产生数据不一致。</li>
</ul>
<h2><a id="tcc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCC</h2>
<p>分为 Try - Confirm/Cancel 阶段，核心思想是：针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）</p>
<ul>
<li><strong>Try</strong>：对业务系统做检测及资源预留，例如把资源转到中间态，比如账户扣除的金额可以先存放到一个中间账户。这一步参与者是需要在本地提交事务的（但不是全局事务）。</li>
<li><strong>Confirm</strong>：确认执行业务操作</li>
<li><strong>Cancel</strong>：取消执行业务操作</li>
</ul>
<h3><a id="%E4%B8%8E2pc%E5%8C%BA%E5%88%AB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与 2PC 区别？</h3>
<p>TCC 事务的处理流程与 2PC 两阶段提交类似，不过 2PC 通常都是在跨库的 DB 层面（提交以前都阻塞持有数据库事务锁住资源），而 TCC 本质上就是一个应用层面的 2PC，需要通过业务逻辑来实现。优势在于降低锁冲突、提高吞吐量，不足之处则在于对应用的侵入性非常强。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16257534482530.html">分布式锁</a></h1>
			<p class="meta"><time datetime="2021-07-08T22:10:48+08:00" 
			pubdate data-updated="true">2021/07/08</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95">数据库唯一索引</a></li>
<li><a href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">Redis 分布式锁</a>
<ul>
<li><a href="#setnx">setNx</a></li>
<li><a href="#redlock">RedLock</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8redission%E8%90%BD%E5%9C%B0">使用 Redission 落地</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据库唯一索引</h2>
<p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p>
<p>存在以下几个问题：</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<h2><a id="redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Redis 分布式锁</h2>
<h3><a id="setnx" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setNx</h3>
<ol>
<li>如果不存在则设置 <code>setNx(key, value)</code>，<code>key</code> 就是锁，<code>value</code> 要设置成一个与进程相关的字符串，比如 <code>随机值 + 线程名</code>，用于线程判断是否为自己设置的锁，防止删了其他进程设置的锁。</li>
<li>在 <code>final</code> 里删除 <code>key</code>，用于解锁。（官方推荐使用 lua 脚本）</li>
<li>为了防止宕机造成的没有执行 <code>final</code> 解锁，所以在 <code>setNx</code> 同时要指定过期时间（set + 过期 必须保证原子性）。</li>
</ol>
<h3><a id="redlock" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RedLock</h3>
<p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p>
<ul>
<li>尝试从 N 个互相独立 Redis 实例获取锁；</li>
<li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li>
<li>如果获取锁失败，就到每个实例上释放锁。</li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8redission%E8%90%BD%E5%9C%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 Redission 落地</h3>
<p>要解决过期时间内没有完成业务逻辑和集群问题，如果自己编码解决非常复杂，并且对业务侵入过大，推荐使用 Redission 框架实现。<br />
Redission 封装了锁的实现，其继承了 JUC 的接口，让我们像操作我们的本地锁一样去操作 Redission 的 Lock。</p>
<pre><code class="language-java">RLock lock = redission.getLock(REDIS_LOCK);
lock.lock(); // 加锁

try {
    // ...
} finally {
    if (lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread()) {
        lock.unlock(); // 解锁
    }
}
</code></pre>
<p>Redission 也实现了 RedLock 锁：</p>
<pre><code class="language-java">RLock rlock1 = redission.getLock(REDIS_LOCK1);
RLock rlock2 = redission.getLock(REDIS_LOCK2);
RLock rlock3 = redission.getLock(REDIS_LOCK3);

RedissionRedLock lock = new RedissionRedLock(rlock1, rlock2, rlock3);

lock.lock();
...
lock.unlock();
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16241109085894.html">黏包半包</a></h1>
			<p class="meta"><time datetime="2021-06-19T21:55:08+08:00" 
			pubdate data-updated="true">2021/06/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E9%BB%8F%E5%8C%85">黏包</a></li>
<li><a href="#%E5%8D%8A%E5%8C%85">半包</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E9%BB%8F%E5%8C%85">解决黏包</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE">协议</a>
<ul>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE">自定义协议</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="%E9%BB%8F%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>黏包</h2>
<p>现象：发送 abc abc，接受 abcabc<br />
原因：</p>
<ul>
<li>接收方 ByteBuf 设置太大</li>
<li>接收方处理消息不及时，同时滑动窗口空余很多</li>
<li>发送方的 Nagle 算法：由于报文都需要添加报头，当发送消息很小时，也需要添加报文头，Nagle 算法可能将多个小的消息合成一个大的消息发送。</li>
</ul>
<h2><a id="%E5%8D%8A%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>半包</h2>
<p>现象：发送 abcabc，接受 abc abc<br />
原因：</p>
<ul>
<li>接收方 ByteBuf 设置太小</li>
<li>接收方的滑动窗口不够了，发送方只能先发一部分，收到 ack 后再发剩下的</li>
<li>链路层：MSS 限制，网卡可能对发送数据有限制，发送的数据超过限制后，会将数据切分</li>
</ul>
<h2><a id="%E8%A7%A3%E5%86%B3%E9%BB%8F%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决黏包</h2>
<ul>
<li>
<p>短链接：每发一次数据就断开连接。效率极低，也无法解决半包问题。</p>
</li>
<li>
<p>定长解码器（<code>FixedLengthFrameDecoder</code>）：一个特殊的 handler，需要双方协商消息固定长度，接收时遇到半包可以等待接受，遇到黏包消息可以拆分。会造成浪费，因为不足长度的消息需要用无意义的字节填充。</p>
</li>
<li>
<p>分隔符解码器：需要指定一个最大长度。效率也不高，因为需要依次查看消息，查找分隔符。</p>
<ul>
<li><code>LineBasedFrameDecoder</code>: 换行分隔符解码器，支持 <code>\n</code> <code>\r\n</code>；</li>
<li><code>DelimiterFrameDecoder</code>: 自定义分隔符解码器</li>
</ul>
</li>
<li>
<p>预设长度（<code>LengthFeildFrameDecoder</code>）：数据的长度约定在数据包里，消息格式为 <code>定长字节表示内容长度 + 实际内容</code></p>
<p><img src="media/16241109085894/16241163684377.jpg" alt="" class="mw_img_center" style="width:840px;display: block; clear:both; margin: 0 auto;" /></p>
</li>
</ul>
<h2><a id="%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>协议</h2>
<p>Netty 提供了 Redis、Http 等常用协议的编解码器</p>
<ol>
<li>
<p>Http：<code>HttpServerCodec</code></p>
<pre><code class="language-java">.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() { // 绑定 handle
        @Override
        protected void initChannel(NioSocketChannel channel) {
            channel.pipeline()
                    .addLast(new LoggingHandler(LogLevel.DEBUG))
                    .addLast(new HttpServerCodec()) // 包含两个：HttpRequestDecoder, HttpResponseEncoder
                    // 上一步解析成两个对象，请求头 DefaultHttpRequest，请求体 LastHttpContent
                    // 这里只关心 DefaultHttpRequest
                    .addLast(new SimpleChannelInboundHandler&lt;DefaultHttpRequest&gt;() {

                        @Override
                        protected void channelRead0(ChannelHandlerContext ctx, DefaultHttpRequest msg) throws Exception {
                            System.out.println(msg.uri());
                            // 返回
                            byte[] bytes = &quot;&lt;h1&gt;hello world!&lt;/h1&gt;&quot;.getBytes();
                            DefaultFullHttpResponse response = new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK); // http协议版本号、状态码
                            response.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, bytes.length);
                            response.content().writeBytes(bytes);
                            ctx.writeAndFlush(response);
                        }
                    });
        }
</code></pre>
</li>
</ol>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义协议</h3>
<p>可以继承 <code>ByteToMessageCodec&lt;Message&gt;</code> 或 <code>MessageToMessageCodec&lt;Message&gt;</code> 父类（区别在于是否可以被多个 EventLoop 共享），重写 <code>encode</code> 和 <code>decode</code> 方法，自己设计协议，既可以出站也可以入站。<br />
在绑定自定义协议编解码器前，配合帧解码器 <code>LengthFeildFrameDecoder</code> 指明自定义协议中 <code>length</code> 的偏移量，防止黏包半包问题。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16232540580406.html">Hello, Netty</a></h1>
			<p class="meta"><time datetime="2021-06-09T23:54:18+08:00" 
			pubdate data-updated="true">2021/06/09</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF">服务端</a></li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li>
</ul>
</div>
<h2><a id="%E6%9C%8D%E5%8A%A1%E7%AB%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>服务端</h2>
<pre><code class="language-java">public static void main(String[] args) {
    new ServerBootstrap()
            .group(new NioEventLoopGroup()) // 新建 EventLoop
            .channel(NioServerSocketChannel.class) // 指定 channel 类型
            .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() { // 绑定 handle
                @Override
                protected void initChannel(NioSocketChannel channel) throws Exception {
                    channel.pipeline()
                            .addLast(new StringDecoder())
                            .addLast(new ChannelInboundHandlerAdapter() {
                                @Override
                                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                                    System.out.println(msg);
                                }
                            });
                }
            })
            .bind(8080);
}
</code></pre>
<h2><a id="%E5%AE%A2%E6%88%B7%E7%AB%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>客户端</h2>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ChannelFuture bootstrap = new Bootstrap()
            .group(new NioEventLoopGroup())
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() {
                @Override
                protected void initChannel(NioSocketChannel channel) throws Exception {
                    channel.pipeline().addLast(new StringEncoder());
                }
            })
            .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))
            .sync(); // 阻塞，直到连接建立成功

    bootstrap.channel().writeAndFlush(&quot;hello, netty&quot;); // 获得 channel 发送数据
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16251055746690.html">select & poll & epoll</a></h1>
			<p class="meta"><time datetime="2021-07-01T10:12:54+08:00" 
			pubdate data-updated="true">2021/07/01</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a>
<ul>
<li><a href="#lt-et">LT &amp; ET</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F">如何选择？</a></li>
</ul>
</div>
<h2><a id="select" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>select</h2>
<pre><code class="language-c">int select(n, readfds, writefds, exceptfds, timeout)
</code></pre>
<p>接受多个代表不同事件的 bitmap 作为描述符掩码，默认1024位，标志哪个描述符是需要监听的，然后调用 select，把描述符拷贝进内核，内核判断哪个描述符发生了事件，用户程序阻塞。<br />
有事件到达时，内核将 bitmap 置位，标志对应位置的描述符发生了事件，然后返回用户态，用户态遍历看看哪个有数据可以读。</p>
<p>缺点：</p>
<ul>
<li>bitmap大小有限制；</li>
<li>会将 bitmap 置位，不可重用，每次读完都需要重新创建 bitmap；</li>
<li>每次调用都需要将描述符拷贝进内核，开销大；</li>
<li>内核态返回后，用户态还是需要 O(n) 遍历描述符检查哪个描述符可用。</li>
</ul>
<h2><a id="poll" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>poll</h2>
<pre><code class="language-c">int poll(struct pollfd *fds, nfds, timeout);
</code></pre>
<p>将 bitmap 改成了结构体，结构体封装了（描述符、事件、revent），内核判断有事件到达，置位的是结构体里的 revent，而不是直接修改描述符，返回用户态后遍历查找可用描述符。</p>
<p>解决的问题：</p>
<ul>
<li>数组大小没有限制；</li>
<li>内核置位的是 revent，用户态处理完事件后可以将 revent 重置，因此fds 可重用。</li>
</ul>
<p>没有解决的问题：</p>
<ul>
<li>每次调用都需要将描述符拷贝进内核；</li>
<li>用户态需要 O(n) 遍历。</li>
</ul>
<h2><a id="epoll" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>epoll</h2>
<pre><code class="language-c">int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
</code></pre>
<p>首先用 <code>epoll_create()</code> 新建一个占位，然后 <code>epoll_ctl()</code> 把文件描述符直接注册在内核的一棵红黑树上，有事件到达时，内核将有事件的描述符加入到一个链表中管理，用户态调用 <code>epoll_wait()</code> 便可以得到事件完成的描述符。</p>
<p>优点：</p>
<ul>
<li>数量没有限制；</li>
<li>只需要将描述符从进程缓冲区向内核缓冲区拷贝一次；</li>
<li>进程不需要通过轮询来获得事件完成的描述符。</li>
</ul>
<h3><a id="lt-et" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LT &amp; ET</h3>
<ul>
<li>Level Trigger：水平触发模式，一个事件只要有，就会一直触发</li>
<li>Edge Trigger：边缘触发模式，只有一个事件从无到有才会触发</li>
</ul>
<p>这两个词汇来自电学术语，你可以将 fd 上有数据认为是高电平，没有数据认为是低电平，将 fd 可写认为是高电平，fd 不可写认为是低电平。那么水平模式的触发条件是状态处于高电平，而边缘模式的触发条件是新来一次电信号将当前状态变为高电平。</p>
<ol>
<li>读<br />
LT：只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；<br />
ET：每新来一次数据就会触发一次，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。</li>
<li>写<br />
LT：如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；<br />
ET：只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。</li>
</ol>
<h2><a id="%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何选择？</h2>
<ul>
<li>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</li>
<li>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li>
<li>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接，因为频繁调用 <code>epoll_ctl()</code> 降低效率。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16231619251356.html">Selector</a></h1>
			<p class="meta"><time datetime="2021-06-08T22:18:45+08:00" 
			pubdate data-updated="true">2021/06/08</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"></div>
<p>多路复用：单线程可以配合 Selector 完成对多个 channel 可读写事件的监控，仅针对网络 IO</p>
<pre><code class="language-java">@Test
public void server() throws IOException {
    Selector selector = Selector.open(); // 创建 selector
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 创建 server channel
    serverSocketChannel.bind(new InetSocketAddress(8080)); // 监听 8080
    serverSocketChannel.configureBlocking(false); // channel 必须工作在非阻塞模式
    // 注册到 selector, 指定一个监听事件和一个附件（buffer）
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT, ByteBuffer.allocate(16));

    while (true) {
        selector.select(); // 使得 selector 阻塞在这里，直到有事件
        // 所有产生事件的 key 被放到了 selectedKeys 这个 set 里
        Iterator&lt;SelectionKey&gt; selectedKeysIterator = selector.selectedKeys().iterator();
        while (selectedKeysIterator.hasNext()) {
            SelectionKey key = selectedKeysIterator.next();
            // 一个事件被处理后，只会在 selectedKeys 里把事件删除，key 并不会删除，下次迭代就会出问题，一定要手动删除
            selectedKeysIterator.remove();
            if (key.isAcceptable()) {
                ServerSocketChannel channel = (ServerSocketChannel) key.channel(); // 通过 key 获取 channel
                SocketChannel socketChannel = channel.accept();
                // 建立连接后再把这个连接的读事件加入 selector 的监听
                socketChannel.configureBlocking(false);
                socketChannel.register(selector, SelectionKey.OP_READ);
            } else if (key.isReadable()) {
                try {
                    // 通过 key 获取 channel，用来读
                    SocketChannel channel = (SocketChannel) key.channel();
                    ByteBuffer buffer = (ByteBuffer) key.attachment(); // 获取这个 key 的 buffer
                    if (channel.read(buffer) == -1) { // 客户端关闭会发送一个读事件，值是 -1
                        key.cancel();
                    }
                    buffer.flip();
                    System.out.println(StandardCharsets.UTF_8.decode(buffer));
                } catch (IOException e) {
                    e.printStackTrace();
                    key.cancel(); // 有异常就把这个事件 取消
                }
            }
        }
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16231408619343.html">ByteBuffer</a></h1>
			<p class="meta"><time datetime="2021-06-08T16:27:41+08:00" 
			pubdate data-updated="true">2021/06/08</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">内部结构</a></li>
<li><a href="#buffer%E7%B1%BB%E5%9E%8B">Buffer 类型</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E9%BB%8F%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85">处理黏包、拆包</a></li>
</ul>
</div>
<h2><a id="%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用</h2>
<pre><code class="language-java">// 获取 channel
try (FileChannel channel = new FileInputStream(&quot;data.txt&quot;).getChannel()) {
    // 获取 buffer
    ByteBuffer buffer= ByteBuffer.allocate(10);
    // 读取 channel --&gt; buffer
    while(channel.read(buffer) != -1) {
        buffer.flip(); // 将 buffer 切换至读模式
        while(buffer.hasRemaining()) {
            System.out.println((char) buffer.get());
        }
        System.out.println(&quot;------&quot;);
        buffer.clear(); // 将 buffer 切换至写模式
    }
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<h2><a id="%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内部结构</h2>
<p><strong>为什么读取数据需要切换读写模式？</strong></p>
<p>内部是一个数组的形式，有三个属性：capacity、position、limit</p>
<ol>
<li>初始状态，position 在起始位置代表从这里写，limit 在末尾代表最多能写到这里，每写一个字节，position 往后移一个位置</li>
<li>读取时，<code>flip();</code> 把 position 移到开始位置代表从这里开始读，而 limit 移到写入的最后一个字节位置，代表最多可以读到这里</li>
<li>读取完毕后，<code>clear();</code> 把指针设为初始状态；如果没有读完，可以使用 <code>compact</code> 把没有读取的字节放到缓冲区开头，把已经读取的舍弃，position 移到没有读取的字节后面</li>
</ol>
<h2><a id="buffer%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Buffer 类型</h2>
<p><code>java.nio.HeapByteBuffer</code>: Java 堆内存，读写效率低，收到 GC 影响（标记压缩为了内存紧凑会移动）<br />
<code>java.nio.DirectByteBuffer</code>: 直接内存，读写效率高（少一次拷贝），但是分配速度慢，需要合理释放</p>
<h2><a id="%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用方法</h2>
<p><code>get(i)</code>: 直接读取第 i 个索引的位置，不改变 position 位置<br />
<code>rewind()</code>: 把 position 置 0，从头读<br />
<code>mark() &amp; reset</code>: <code>mark</code> 记录 position 位置，<code>reset</code> 将 position 重置到 mark 的位置</p>
<ul>
<li>
<p>String --&gt; ByteBuffer:</p>
<ul>
<li><code>buffer.put(&quot;xxxx&quot;.getBytes())</code></li>
<li><code>StandardCharsets.UTF_8.encode(&quot;xxxx&quot;)</code></li>
<li><code>ByteBuffer.wrap(&quot;xxxx&quot;.getBytes())</code></li>
</ul>
</li>
<li>
<p>ByteBuffer --&gt; String:</p>
<ul>
<li><code>StandardCharsets.UTF_8.decode(buffer)</code></li>
</ul>
</li>
</ul>
<h2><a id="%E5%A4%84%E7%90%86%E9%BB%8F%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理黏包、拆包</h2>
<pre><code class="language-java">private void split(ByteBuffer buffer) {
    buffer.flip();
    for (int i = 0; i &lt; buffer.limit(); i++) {
        if (buffer.get(i) == '\n') { // 找到分隔符
            int length = i + 1 - buffer.position();
            ByteBuffer target = ByteBuffer.allocate(length);
            for (int j = 0; j &lt; length; j++) { // 从 position 读取到分隔符
                target.put(buffer.get());
            }
            target.flip();
            System.out.println(StandardCharsets.UTF_8.decode(target));
        }
    }
    buffer.compact(); // 为了将拆包的内容留给下一次使用
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16231372487264.html">NIO</a></h1>
			<p class="meta"><time datetime="2021-06-08T15:27:28+08:00" 
			pubdate data-updated="true">2021/06/08</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6">三大组件</a>
<ul>
<li><a href="#channel">Channel</a></li>
<li><a href="#buffer">Buffer</a></li>
<li><a href="#selector">Selector</a></li>
</ul>
</li>
<li><a href="#nio-bio-aio">NIO &amp; BIO &amp; AIO</a></li>
</ul>
</div>
<h2><a id="%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三大组件</h2>
<h3><a id="channel" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Channel</h3>
<p><code>channel</code> 类似于 <code>stream</code>，是读写数据的双向通道，可以从 <code>channel</code> 将数据读入 <code>buffer</code>，也可以将 <code>buffer</code> 的数据写入 <code>channel</code>。</p>
<p>常见的 <code>Channel</code> 有：</p>
<ul>
<li><code>FileChannel</code>：文件</li>
<li><code>DatagramChannel：UDP</code></li>
<li><code>SocketChannel</code>：服务器、客户端 TCP</li>
<li><code>ServerSocketChannel</code>：服务器 TCP</li>
</ul>
<h3><a id="buffer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Buffer</h3>
<p><code>buffer</code> 用来缓冲读写数据。常见的 <code>buffer</code> 有：</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>shortBuffer</code></li>
<li><code>IntBuffer</code></li>
<li>... ...</li>
</ul>
<p><strong>例子：Channel &amp; Buffe</strong></p>
<pre><code class="language-java">// 获取 channel
try (FileChannel channel = new FileInputStream(&quot;data.txt&quot;).getChannel()) {
    // 获取 buffer
    ByteBuffer buffer= ByteBuffer.allocate(10);
    // 读取 channel --&gt; buffer
    while(channel.read(buffer) != -1) {
        buffer.flip(); // 将 buffer 切换至读模式
        while(buffer.hasRemaining()) {
            System.out.println((char) buffer.get());
        }
        System.out.println(&quot;------&quot;);
        buffer.clear(); // 将 buffer 切换至写模式
    }
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<h3><a id="selector" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Selector</h3>
<p>当有多个网络连接时，如何处理？</p>
<ul>
<li>多线程版：每一个 <code>socket</code> 连接用一个线程处理。内存占用高，线程上下文切换成本高，只适合连接数少的场景</li>
<li>线程池版：解决了内存占用和切换成本问题，但是阻塞模式下，一个线程仅能处理一个 <code>socket</code> 连接直到断开连接。只适合短连接场景</li>
<li><strong><code>selector</code> 版</strong>：selector 的作用就是配合一个线程来管理多个 <code>channel</code> ，能够感知这些 <code>channel</code> 上发生的事件，然后交给线程处理，这些 <code>channel</code> 是非阻塞的，不会让线程吊死在一个 <code>channel</code> 上。适合连接数多，但流量低的场景。</li>
</ul>
<h2><a id="nio-bio-aio" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NIO &amp; BIO &amp; AIO</h2>
<ol>
<li>
<p>stream vs channel</p>
<ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
</li>
<li>
<p>IO 模型<br />
分为：同步阻塞、同步非阻塞、同步多路复用、异步非阻塞、<del>异步阻塞</del>（没有此情况）</p>
<ul>
<li>同步（IO）：线程自己去获取结果（一个线程）</li>
<li>异步（AIO）：线程自己不去获取结果，而是由其它线程<strong>送结果</strong>（至少两个线程）</li>
</ul>
<p>当调用一次 <code>channel.read</code> 或 <code>stream.read</code> 后，会切换至操作系统内核态来完成真正数据读取，而在内核态读取又分为两个阶段：等待数据阶段、复制数据阶段</p>
<ul>
<li>
<p>同步阻塞<br />
<img src="media/16231372487264/0039.png" alt="0039" /></p>
</li>
<li>
<p>同步非阻塞<br />
<img src="media/16231372487264/0035.png" alt="0035" /></p>
</li>
<li>
<p>多路复用<br />
多路复用的 selector 也是阻塞，那么和阻塞IO有什么区别？<br />
阻塞IO 在一个事件没有处理完或没有此事件时，必须等待处理完或此事件发生（例如，线程正在等待读，但是没有读事件，此时所有的其他连接事件都无法进行）；而多路复用虽然 selector 是阻塞的，但是 channel 必须是非阻塞的，selector 可以监听多个 channel 所有的注册事件，不用专门匹配某个类型事件而造成另外类型的事件无法执行。<br />
<img src="media/16231372487264/0038.png" alt="0038" /></p>
</li>
<li>
<p>异步非阻塞<br />
都是非阻塞，和同步非阻塞有什么区别？<br />
同步非阻塞，如果调用 read 拿不到值，如果还想用，需要再次 read，通常需要使用 while 循环；异步非阻塞调用 read 后就可以干自己的其他的事情了，需要的时候只需要检查回调值就可以了<br />
<img src="media/16231372487264/0037.png" alt="0037" /></p>
</li>
</ul>
</li>
</ol>
<p><img src="media/16231372487264/16246320247621.jpg" alt="" style="width:735px;" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16240887909460.html">ByteBuf</a></h1>
			<p class="meta"><time datetime="2021-06-19T15:46:30+08:00" 
			pubdate data-updated="true">2021/06/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="#%E7%BB%84%E6%88%90">组成</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5">读取写入</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6">内存回收</a></li>
<li><a href="#%E3%80%90%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%91%E6%96%B9%E6%B3%95">【零拷贝】方法</a>
<ul>
<li><a href="#slice">slice</a></li>
<li><a href="#duplicate">duplicate</a></li>
<li><a href="#compositebuffer%E5%88%9B%E5%BB%BA-compositebytebuf%E5%AF%B9%E8%B1%A1">compositeBuffer 创建 CompositeByteBuf 对象</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D">文件传输的零拷贝</a></li>
</ul>
</div>
<p>对字节数组的封装</p>
<ul>
<li>
<p>使用</p>
<pre><code class="language-java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);
</code></pre>
</li>
</ul>
<h2><a id="%E4%BC%98%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优点</h2>
<ul>
<li>直接内存：默认创建直接内存，虽然创建销毁代价大，但是读写性能高，不受 GC 影响，需要主动释放</li>
<li>池化：可以重用池中的 ByteBuf 对象，高并发下可以节约内存，默认开启</li>
<li>自动扩容：写入大小不超过 512，选择下一个 16 的整数倍；如果超过 512，选择下一个 2^n。</li>
<li>读写指针分离，不用切换读写模式</li>
<li>很多方法体现了零拷贝</li>
<li>支持链式调用，使用方便</li>
</ul>
<h2><a id="%E7%BB%84%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组成</h2>
<ul>
<li>容量：初始容量</li>
<li>最大容量：默认是 2^31 ，当容量不够，自动触发扩容</li>
<li>写指针：记录当前写的位置</li>
<li>读指针：记录当前读的位置，最多能读到写指针</li>
</ul>
<h2><a id="%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>读取写入</h2>
<p>读取使用方法 <code>readInt readByte ...</code>，读取过的字节就作废了，下次再读就继续往后读，如果还想再读，可以使用标记：</p>
<pre><code class="language-java">markReaderIndex();
readInt();
... ...
resetReaderIndex();
</code></pre>
<p>或者使用 get 方法，不会改变读指针</p>
<h2><a id="%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存回收</h2>
<ul>
<li><code>UnpooledHeapByteBuf</code>：等待 GC 自动回收</li>
<li><code>UnpooledDirectByteBuf</code>：特殊方法回收</li>
<li><code>PooledByteBuf</code>：更复杂的规则回收</li>
</ul>
<p>Netty 提供了统一的引用计数法回收内存，每个 ByteBuf 都实现了 <code>ReferenceCounted</code> 接口：初始时引用计数为 1；调用 release 使计数 -1，等于 0 时内存被回收；调用 retain 使计数 +1。</p>
<p>由于 pipeline 有可能使当前 handler 的 ByteBuf 传给下一个 handler，因此<strong>谁最后使用 ByteBuf 谁调用 release</strong>。</p>
<p>如果我们不手动释放，pipeline 队列的 head 和 tail 也会自动帮我们释放（前提是 ByteBuf 被我们传到了 head 和 tail）。</p>
<h2><a id="%E3%80%90%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%91%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>【零拷贝】方法</h2>
<h3><a id="slice" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>slice</h3>
<p><code>slice</code> 切片可以将原始 ByteBuf 切成多个小的 ByteBuf，使用的还是原来的内存，并没有发生复制，只不过每个切片在原油的 ByteBuf 位置上维护读写指针。</p>
<ul>
<li>切片后最大容量有限制</li>
<li>释放原有 ByteBuf，切片不可用</li>
</ul>
<p><img src="media/16240887909460/0011.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<pre><code class="language-java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);
buffer.writeBytes(new byte[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'});
buffer.slice(0, 5);
buffer.slice(5, 5);
</code></pre>
<h3><a id="duplicate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate</h3>
<p>截取了原始 ByteBuf 所有内容，并且没有扩容的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的<br />
注：copy 会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<p><img src="media/16240887909460/0012.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<h3><a id="compositebuffer%E5%88%9B%E5%BB%BA-compositebytebuf%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>compositeBuffer 创建 CompositeByteBuf 对象</h3>
<p>可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>
<pre><code class="language-java">ByteBuf b1 = ByteBufAllocator.DEFAULT.buffer(2);
ByteBuf b2 = ByteBufAllocator.DEFAULT.buffer(2);
b1.writeBytes(new byte[]{'a', 'b'});
b2.writeBytes(new byte[]{'c', 'd'});
CompositeByteBuf b3 = ByteBufAllocator.DEFAULT.compositeBuffer();
b3.addComponents(true, b1, b2); // true 可以使读写指针自动增长
</code></pre>
<h2><a id="%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件传输的零拷贝</h2>
<p>和 netty 的零拷贝不太一样。</p>
<p>java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的。读的时候调用系统接口，先读到内核缓冲区，再复制到用户缓冲区；写的时候先将用户缓冲区内容复制到 Socket 缓冲区，再写入网卡等。<br />
<img src="media/16231372487264/0024.png" alt="0024" /></p>
<p>使用 <code>ByteBuffer.allocateDirect()</code> 获取 <code>DirectByteBuffer</code>，将堆外内存映射到 jvm 内存中来直接访问使用，不受 jvm 垃圾回收的影响，但是读取完还是需要从内核态切换回用户态。<br />
<img src="media/16231372487264/0025.png" alt="0025" /></p>
<p>linux 2.1 后，java 中 <code>transferTo/transferFrom</code> 方法从<strong>用户态</strong>切换至<strong>内核态</strong>，内核读取完后不用切换回用户态就可以直接写入 socket 缓冲区再写入网卡<br />
<img src="media/16231372487264/0026.png" alt="0026" /></p>
<p>linux 2.4 后，java 的 <code>transferTo</code> 方法可以将 <strong>内核缓冲区</strong> 的数据直接写入网卡，不再复制到 Socket 缓冲区。<br />
<img src="media/16231372487264/0027.png" alt="0027" /></p>
<p><strong>零拷贝指的是不在用户和内核之间进行任何拷贝，内核态切换一次，数据拷贝两次，并不是真的指没有任何拷贝。</strong></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16232654501204.html">Handler & PipeLine</a></h1>
			<p class="meta"><time datetime="2021-06-10T03:04:10+08:00" 
			pubdate data-updated="true">2021/06/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"></div>
<p><code>ChannelHandler</code> 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 <code>ChannelHandler</code> 被连成一串，就是 <code>Pipeline</code>(双向链表)</p>
<ul>
<li>入站处理器通常是 <code>ChannelInboundHandlerAdapter</code> 的子类，主要用来读取客户端数据，写回结果，从前往后调用</li>
<li>出站处理器通常是 <code>ChannelOutboundHandlerAdapter</code> 的子类，主要对写回结果进行加工，从后往前调用（如果使用 ctx 的 write 是从当前 handler 往前找，而使用 channel 的 write 是从 pipeline 尾开始找）</li>
</ul>
<p><img src="media/16232654501204/16232668955891.jpg" alt="" class="mw_img_center" style="width:619px;display: block; clear:both; margin: 0 auto;" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16232586916959.html">Channel</a></h1>
			<p class="meta"><time datetime="2021-06-10T01:11:31+08:00" 
			pubdate data-updated="true">2021/06/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#channelfuture">ChannelFuture</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5">异步</a></li>
</ul>
</div>
<p>channel 代表数据的通道，主要方法：</p>
<ul>
<li><code>close()</code> 可以用来关闭 channel，异步</li>
<li><code>closeFuture()</code> 用来处理 channel 的关闭，获取 ChannelFuture</li>
<li><code>sync</code> 方法作用是同步等待 channel 连接或关闭</li>
<li><code>addListener</code> 方法是异步等待 channel 关闭</li>
<li><code>pipeline()</code> 方法添加处理器</li>
<li><code>write()</code> 方法将数据写入</li>
<li><code>writeAndFlush()</code> 方法将数据写入并刷出</li>
</ul>
<h2><a id="channelfuture" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ChannelFuture</h2>
<p>客户端通过 <code>connect</code> 返回的是 ChannelFuture，可以通过 <code>channel()</code> 获取 Channel，<code>connect</code> 是异步的，需要使用 ChannelFuture 的 <code>sync()</code> 等待，或者添加回调对象，在回调里处理。</p>
<p>调用 <code>Channel</code> 的 <code>close</code> 异步关闭后，通过 <code>closeFuture()</code> 获取  ChannelFuture 对象，在使用它的 <code>sync()</code> 等待关闭完成。</p>
<pre><code class="language-java">Channel channel = channelFuture.channel();
channel.close();
ChannelFuture closeFuture = channel.closeFuture();
closeFuture.sync();
System.out.println(&quot;close ok.&quot;);
group.shutdownGracefully();
</code></pre>
<h2><a id="%E5%BC%82%E6%AD%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>异步</h2>
<p><strong>netty 大部分方法都是异步的，为什么这么设计？</strong><br />
为了提高单位时间的吞吐量，并不能真正提升效率，例如看病，把看病流程拆分成几个步骤，每隔医生负责一个流程，达到流水线的效果，提高单位时间看的病人的数量，其实每个病人看病的时间反而会增加（各个病人切换）<br />
<img src="media/16232586916959/16232632899146.jpg" alt="" class="mw_img_center" style="width:273px;display: block; clear:both; margin: 0 auto;" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16232544515372.html">EventLoop</a></h1>
			<p class="meta"><time datetime="2021-06-10T00:00:51+08:00" 
			pubdate data-updated="true">2021/06/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#eventloop">EventLoop</a></li>
<li><a href="#eventloopgroup">EventLoopGroup</a>
<ul>
<li><a href="#boss-worker">Boss &amp; Worker</a></li>
<li><a href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E5%88%86">进一步细分</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="eventloop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>EventLoop</h2>
<p><code>EventLoop</code> 本质是一个单线程执行器（同时维护了一个 <code>Selector</code>），里面有 run 方法处理多个 <code>Channel</code> 上源源不断的 io 事件。<br />
继承了 <code>j.u.c.ScheduledExecutorService</code>，因此包含了线程池中所有的方法，例如普通任务 <code>execute</code>，定时任务 <code>scheduleAtFixedRate</code></p>
<ul>
<li>一旦 <code>Chaneel</code> 建立了连接，就会和一个 <code>EventLoop</code> 绑定，后续该 <code>Channel</code> 所有事件都由这一个 <code>EventLoop</code> 处理。</li>
</ul>
<h2><a id="eventloopgroup" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>EventLoopGroup</h2>
<p><code>EventLoopGroup</code> 是一组 <code>EventLoop</code>，<code>Channel</code> 一般会调用 <code>EventLoopGroup</code> 的 <code>register</code> 方法来绑定其中一个 <code>EventLoop</code>，后续这个 <code>Channel</code> 上的 io 事件都由此 <code>EventLoop</code> 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li><code>EventLoopGroup</code> 如果不指定 <code>EventLoop</code> 数量，会默认读取配置文件，没有配置文件会默认采用 2 倍核心数，如果 API 获取处理器信息失败，默认创建 1 个 <code>EventLoop</code>。</li>
<li><code>EventLoopGroup</code> 的 <code>next()</code> 方法可以循环返回内部的 <code>EventLoop</code> 对象</li>
</ul>
<h3><a id="boss-worker" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Boss &amp; Worker</h3>
<p>Netty 建议使用使用两个 Group，一个 Group（Boss） 只处理 accept 事件，另一个 Group（Worker） 处理其他事件。</p>
<pre><code class="language-java">new ServerBootstrap().group(new NioEventLoopGroup(), new NioEventLoopGroup());
</code></pre>
<h3><a id="%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进一步细分</h3>
<p>把耗时的 handler 专门交给其他的线程做，防止管理 channel 的 eventloop 处理某个消息太耗时，无法完成其他的事件。</p>
<p><img src="media/16232544515372/16232580766593.jpg" alt="" class="mw_img_center" style="width:537px;display: block; clear:both; margin: 0 auto;" /></p>
<pre><code class="language-java">DefaultEventLoopGroup group = new DefaultEventLoopGroup(); // 专门处理耗时的 handler
new ServerBootstrap()
        .group(new NioEventLoopGroup(), new NioEventLoopGroup()) // 新建 EventLoop
        .channel(NioServerSocketChannel.class) // 指定 channel 类型
        .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() { // 绑定 handle
            @Override
            protected void initChannel(NioSocketChannel channel) throws Exception {
                channel.pipeline()
                        .addLast(new StringDecoder())
                        // 把自定义 handler 指定给一个独立的 EventLoopGroup
                        .addLast(group, &quot;my_handler&quot;, new ChannelInboundHandlerAdapter() {
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                                // Thread: defaultEventLoopGroup-2-1, msg: hello, netty
                                System.out.println(&quot;Thread: &quot; + Thread.currentThread().getName() + &quot;, msg: &quot; + msg);
                            }
                        });
            }
        })
        .bind(8080);
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15784050576311.html">CXF 支持的数据类型</a></h1>
			<p class="meta"><time datetime="2020-01-07T21:50:57+08:00" 
			pubdate data-updated="true">2020/01/07</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>CXF 支持以下数据类型：</p>
<ol>
<li>简单数据类型：int、string、boolean ... ...</li>
<li>集合：List、Map、Set ... ...</li>
<li>自定义数据结构</li>
</ol>
<p>JDK 开发的 WebService 不支持 Map</p>
<ol>
<li>
<p>Server：<br />
<img src="media/15784050576311/clipboard-5.png" alt="clipboard-5" /></p>
</li>
<li>
<p>生成代码：<br />
<img src="media/15784050576311/clipboard-6.png" alt="clipboard-6" /></p>
</li>
<li>
<p>Client：<br />
<img src="media/15784050576311/clipboard-7.png" alt="clipboard-7" /></p>
</li>
<li>
<p>运行结果：</p>
<ul>
<li>
<p>Server 端：<br />
<img src="media/15784050576311/clipboard-8.png" alt="clipboard-8" /></p>
</li>
<li>
<p>Client 端：<br />
<img src="media/15784050576311/clipboard-9.png" alt="clipboard-9" /></p>
</li>
</ul>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15784046277661.html">WSDL 解析</a></h1>
			<p class="meta"><time datetime="2020-01-07T21:43:47+08:00" 
			pubdate data-updated="true">2020/01/07</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>wsdl 文档格式组成部分为</p>
<ul>
<li>definitions
<ul>
<li>types</li>
<li>message</li>
<li>portType</li>
<li>binding</li>
<li>service</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;wsdl:definitions
    targetNamespace=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;
    xmlns:tns=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;
    xmlns:wsdlsoap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;
    xmlns:soap12=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns:soapenc11=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;
    xmlns:soapenc12=&quot;http://www.w3.org/2003/05/soap-encoding&quot;
    xmlns:soap11=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;
    &lt;wsdl:types&gt;
        &lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
            attributeFormDefault=&quot;qualified&quot; elementFormDefault=&quot;qualified&quot;
            targetNamespace=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;&gt;
            &lt;xsd:element name=&quot;sayHello&quot;&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                        &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot;
                            name=&quot;name&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
            &lt;xsd:element name=&quot;sayHelloResponse&quot;&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                        &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot;
                            name=&quot;out&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;
    &lt;wsdl:message name=&quot;sayHelloResponse&quot;&gt;
        &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHelloResponse&quot; /&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name=&quot;sayHelloRequest&quot;&gt;
        &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHello&quot; /&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:portType name=&quot;HelloServicePortType&quot;&gt;
        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;
            &lt;wsdl:input name=&quot;sayHelloRequest&quot;
                message=&quot;tns:sayHelloRequest&quot; /&gt;
            &lt;wsdl:output name=&quot;sayHelloResponse&quot;
                message=&quot;tns:sayHelloResponse&quot; /&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:portType&gt;
    &lt;wsdl:binding name=&quot;HelloServiceHttpBinding&quot;
        type=&quot;tns:HelloServicePortType&quot;&gt;
        &lt;wsdlsoap:binding style=&quot;document&quot;
            transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt;
        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;
            &lt;wsdlsoap:operation soapAction=&quot;&quot; /&gt;
            &lt;wsdl:input name=&quot;sayHelloRequest&quot;&gt;
                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output name=&quot;sayHelloResponse&quot;&gt;
                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:binding&gt;
    &lt;wsdl:service name=&quot;HelloService&quot;&gt;
        &lt;wsdl:port name=&quot;HelloServiceHttpPort&quot;
            binding=&quot;tns:HelloServiceHttpBinding&quot;&gt;
            &lt;wsdlsoap:address
                location=&quot;http://localhost:8080/xfire/services/HelloService&quot; /&gt;
        &lt;/wsdl:port&gt;
    &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;
</code></pre>
<ol>
<li>
<p>definitions<br />
所有的 WSDL 文档的根元素均是 definitions 元素。该元素封装了整个文档，同时通过其 name 提供了一个 WSDL 文档。除了提供一个命名空间外，该元素没有其他作用。<br />
这里通过 xmlns:tns=&quot;<a href="http://com.liuxiang.xfireDemo/HelloService">http://com.liuxiang.xfireDemo/HelloService</a>&quot; 引入了自身，方便调用自身的元素。</p>
<pre><code class="language-xml">&lt;wsdl:definitions
    targetNamespace=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;
    xmlns:tns=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;
    xmlns:wsdlsoap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;
    xmlns:soap12=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns:soapenc11=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;
    xmlns:soapenc12=&quot;http://www.w3.org/2003/05/soap-encoding&quot;
    xmlns:soap11=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;
&lt;/wsdl:definitions&gt;
</code></pre>
</li>
<li>
<p>types<br />
types 元素用于定义 XML 模式内置类型中没有描述的各种数据类型。当声明消息部分的有效负载时，消息定义使用了在 types 元素中定义的数据类型和元素。在本文的 WSDL 文档中的 types 定义：</p>
<pre><code class="language-xml">&lt;wsdl:types&gt;
        &lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
            attributeFormDefault=&quot;qualified&quot; elementFormDefault=&quot;qualified&quot;
            targetNamespace=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;&gt;
            &lt;xsd:element name=&quot;sayHello&quot;&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                        &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot;
                            name=&quot;name&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
            &lt;xsd:element name=&quot;sayHelloResponse&quot;&gt;
                &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                        &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot;
                            name=&quot;out&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;
                    &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;
</code></pre>
<p>上面是数据定义部分，该部分定义了两个元素，一个是 sayHello，一个是sayHelloResponse：<br />
sayHello：定义了一个复杂类型，仅仅包含一个简单的字符串，将来用来描述操作的参入传入部分，样例为：</p>
<pre><code class="language-xml">&lt;sayHello&gt;
    &lt;name&gt;zsc&lt;/name&gt;
&lt;/sayHello&gt;
</code></pre>
<p>sayHelloResponse：定义了一个复杂类型，仅仅包含一个简单的字符串，将来用来描述操作的返回值，样例为：</p>
<pre><code class="language-xml">&lt;sayHelloResponse&gt;
    &lt;out&gt;hello zsc&lt;/out&gt;
&lt;/sayHelloResponse&gt;
</code></pre>
<p>注：import<br />
import 元素使得可以在当前的WSDL文档中使用其他WSDL文档中指定的命名空间中的定义元素。本例子中没有使用import元素。通常在用户希望模块化WSDL文档的时候，该功能是非常有效果的。<br />
import 的格式如下：<code>&lt;wsdl:import namespace=&quot;http://xxx.xxx.xxx/xxx/xxx&quot; location=&quot;http://xxx.xxx.xxx/xxx/xxx.wsdl&quot;/&gt;</code>，如：</p>
<pre><code class="language-xml">&lt;types&gt;
        &lt;xsd:schema&gt;
            &lt;xsd:import namespace=&quot;http://impl.sei.ws_test.vaf714.cn/&quot; schemaLocation=&quot;http://localhost:8989/ws_test/hellosei?xsd=1&quot;/&gt;
        &lt;/xsd:schema&gt;
 &lt;/types&gt;
</code></pre>
<p>必须有 namespace 属性和 location 属性：<br />
namespace 属性：值必须与正导入的 WSDL 文档中声明的 targetNamespace 相匹配；<br />
location 属性：必须指向一个实际的 WSDL 文档，并且该文档不能为空。</p>
</li>
<li>
<p>message<br />
message 元素描述了 Web 服务使用消息的有效负载。message 元素可以描述输出或者接受消息的有效负载；还可以描述 SOAP 文件头和错误 detail 元素的内容。定义 message 元素的方式取决于使用RPC 样式还是文档样式的消息传递。在本文中的 message 元素的定义，本文档使用了采用文档样式的消息传递：</p>
<pre><code class="language-xml">&lt;wsdl:message name=&quot;sayHelloResponse&quot;&gt;
    &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHelloResponse&quot; /&gt;
&lt;/wsdl:message&gt;
&lt;wsdl:message name=&quot;sayHelloRequest&quot;&gt;
     &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHello&quot; /&gt;
 &lt;/wsdl:message&gt;
</code></pre>
<p>该部分是消息格式的抽象定义：定义了两个消息 sayHelloResponse 和 sayHelloRequest：<br />
<code>sayHelloRequest</code>：sayHello 操作的请求消息格式，由一个消息片断组成，名字为 parameters，元素是我们前面定义的 types 中的元素；<br />
<code>sayHelloResponse</code>：sayHello 操作的响应消息格式，由一个消息片断组成，名字为 parameters，元素是我们前面定义的 types 中的元素；<br />
如果采用 RPC 样式的消息传递，只需要将文档中的 element 元素修改为 type 即可。</p>
</li>
<li>
<p>portType<br />
portType 元素定义了 Web 服务的抽象接口。该接口有点类似 Java 的接口，都是定义了一个抽象类型和方法，没有定义实现。在 WSDL 中，portType 元素是由 binding 和 service 元素来实现的，这两个元素用来说明 Web 服务实现使用的 Internet 协议、编码方案以及 Internet 地址。<br />
一个 portType 中可以定义多个 operation，一个 operation 可以看作是一个方法，本文中 WSDL 文档的定义：</p>
<pre><code class="language-xml">&lt;wsdl:portType name=&quot;HelloServicePortType&quot;&gt;
        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;
            &lt;wsdl:input name=&quot;sayHelloRequest&quot; message=&quot;tns:sayHelloRequest&quot; /&gt;
            &lt;wsdl:output name=&quot;sayHelloResponse&quot; message=&quot;tns:sayHelloResponse&quot; /&gt;
        &lt;/wsdl:operation&gt;
&lt;/wsdl:portType&gt;
</code></pre>
<p>portType 定义了服务的调用模式的类型，这里包含一个操作 sayHello 方法，同时包含 input 和 output 表明该操作是一个请求／响应模式，请求消息是前面定义的 sayHelloRequest，响应消息是前面定义的 sayHelloResponse。input 表示传递到 Web 服务的有效负载，output 消息表示传递给客户的有效负载。</p>
</li>
<li>
<p>binding<br />
binding 元素将一个抽象 portType 映射到一组具体协议（SOAO和HTTP）、消息传递样式、编码样式。通常 binding 元素与协议专有的元素和在一起使用，本文中的例子：</p>
<pre><code class="language-xml"> &lt;wsdl:binding name=&quot;HelloServiceHttpBinding&quot; type=&quot;tns:HelloServicePortType&quot;&gt;
        &lt;wsdlsoap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt;
        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;
            &lt;wsdlsoap:operation soapAction=&quot;&quot; /&gt;
            &lt;wsdl:input name=&quot;sayHelloRequest&quot;&gt;
                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output name=&quot;sayHelloResponse&quot;&gt;
                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
&lt;/wsdl:binding&gt;
</code></pre>
<p>这部分将服务访问点的抽象定义与 SOAP HTTP 绑定，描述如何通过 SOAP/HTTP 来访问按照前面描述的访问入口点类型部署的访问入口。其中规定了在具体 SOAP 调用时，应当使用的 soapAction是&quot;&quot;。具体的使用需要参考特定协议定义的元素。</p>
</li>
<li>
<p>service<br />
service 元素包含一个或者多个 port 元素，其中每个 port 元素表示一个不同的 Web 服务。port 元素将 URL 赋给一个特定的 binding，甚至可以使两个或者多个 port 元素将不同的 URL 赋值给相同的binding。</p>
<pre><code class="language-xml">&lt;wsdl:service name=&quot;HelloService&quot;&gt;
        &lt;wsdl:port name=&quot;HelloServiceHttpPort&quot;
            binding=&quot;tns:HelloServiceHttpBinding&quot;&gt;
            &lt;wsdlsoap:address location=&quot;http://localhost:8080/xfire/services/HelloService&quot; /&gt;
        &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;
</code></pre>
<p>这部分是具体的 Web 服务的定义，在这个名为 HelloService 的 Web 服务中，提供了一个服务访问入口，访问地址是 <code>http://localhost:8080/xfire/services/HelloService</code>，使用的消息模式是由前面的binding 所定义的。</p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15784036889043.html">开发 WebService</a></h1>
			<p class="meta"><time datetime="2020-01-07T21:28:08+08:00" 
			pubdate data-updated="true">2020/01/07</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%88%A9%E7%94%A8jdk%E5%BC%80%E5%8F%91-webservice">利用 JDK 开发 WebService</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8cxf%E5%BC%80%E5%8F%91">使用 cxf 开发</a></li>
</ul>
</div>
<p>etest开发方式：</p>
<ul>
<li>JDK 1.6 +</li>
<li>框架：CXF 等</li>
</ul>
<p>开发步骤：</p>
<ul>
<li>开发服务端</li>
<li>开发客户端</li>
</ul>
<h2><a id="%E5%88%A9%E7%94%A8jdk%E5%BC%80%E5%8F%91-webservice" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>利用 JDK 开发 WebService</h2>
<ol>
<li>
<p>开发服务端</p>
<ul>
<li>
<p>新建类作为 SEI ，类加注解 @WebService，方法上加注解 @WebMethod（如果使用接口，那么在接口上两个注解都要加，而实现类只需要加 @WebService 即可）</p>
<ul>
<li>
<p>HelloSEI 接口</p>
<pre><code class="language-java">import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
public interface HelloSEI {
    @WebMethod
    String sayHello(String name);
}
</code></pre>
</li>
<li>
<p>HelloSEI 实现类 HelloSEIImpl</p>
<pre><code class="language-java">import cn.vaf714.ws_test.sei.HelloSEI;
import javax.jws.WebService;

@WebService
public class HelloSEIImpl implements HelloSEI {

    @Override
    public String sayHello(String name) {
        System.out.println(&quot;hello &quot; + name);
        return &quot;Hello I'm WebService Server&quot;;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>main 方法内发布该接口</p>
<pre><code class="language-java">import cn.vaf714.ws_test.sei.impl.HelloSEIImpl;
import javax.xml.ws.Endpoint;

public class Startup {
    public static void main(String[] args) {
        String address = &quot;http://localhost:8989/ws_test/hellosei&quot;;
        Endpoint.publish(address, new HelloSEIImpl());
        System.out.println(&quot;WebService发布成功&quot;);
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>开发客户端</p>
<ul>
<li>
<p>使用 JDK 自带的工具（wsimport）根据 webService 的 url?wsdl（也可是本地 wsdl 文件） 生成代码到客户端目录</p>
<pre><code class="language-plain_text">C:\Users\Acer&gt;d:D:\&gt;cd
D:\Code\Java_IDEA\ws_test_client\src
D:\Code\Java_IDEA\ws_test_client\src&gt;wsimport -encoding utf-8 -keep http://localhost:8989/ws_test/hellosei?wsdl
</code></pre>
<p>可以看到生成的文件<br />
<img src="media/15784036889043/clipboard.png" alt="clipboard" /></p>
</li>
<li>
<p>调用 ws 的方法， 有一个类（wsdl 定义）是用于创建发布的 SEI 接口的工厂，利用它创建出 SEI 后，再调用 SEI 里发布的方法即可。</p>
<pre><code class="language-java">import cn.vaf714.ws_test.sei.impl.HelloSEIImpl;
import cn.vaf714.ws_test.sei.impl.HelloSEIImplService;

public class Startup {
    public static void main(String[] args) {
        HelloSEIImplService service = new HelloSEIImplService();
        HelloSEIImpl helloSEI = service.getHelloSEIImplPort();
        String result = helloSEI.sayHello(&quot;zsc&quot;);
        System.out.println(result);
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>运行结果</p>
<ul>
<li>
<p>客户端<br />
<img src="media/15784036889043/clipboard-4.png" alt="clipboard-4" /></p>
</li>
<li>
<p>服务端<br />
<img src="media/15784036889043/clipboard-3.png" alt="clipboard-3" /></p>
</li>
</ul>
</li>
</ol>
<h2><a id="%E4%BD%BF%E7%94%A8cxf%E5%BC%80%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 cxf 开发</h2>
<p>直接将 cxf 目录 lib 里的 jar 包加入项目即可，生成客户端代码要使用 cxf 目录 bin 目录里的 wsdl2java.bat 工具（使用 idea 可以配置好 cxf 目录，包右键直接生成客户端代码）<br />
<img src="media/15784036889043/clipboard-2.png" alt="clipboard-2" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15784036386496.html">异常解决</a></h1>
			<p class="meta"><time datetime="2020-01-07T21:27:18+08:00" 
			pubdate data-updated="true">2020/01/07</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>java 调用 .net 开发的 webService，生成客户端代码时报错
<ul>
<li>将 wsdl 文档保存到本地</li>
<li>将 wsdl 文件内的 <code>&lt;s:element ref=&quot;s:schema&quot; /&gt;&lt;s:any/&gt;</code> 替换成 <code>&lt;s:any minOccurs=&quot;2&quot; maxOccurs=&quot;2&quot;/&gt;</code></li>
</ul>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15784034414028.html">Schema 约束</a></h1>
			<p class="meta"><time datetime="2020-01-07T21:24:01+08:00" 
			pubdate data-updated="true">2020/01/07</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>
<p>先定义一个 schema 文件，用于约束将要定义的 xml 文件，但是 schema 文件也有一个 schema 文件约束，由 w3c 提供，同时 schema 文件需要指定一个 namespace ，类似于 id ，供 xml 文件引用。<br />
xmlns 属性指定引用的约束<br />
targetNamespace 属性指定 schema 的namespace<br />
elementFormDefault 属性默认写 qualified<br />
<img src="media/15784034414028/%E6%88%AA%E5%9B%BE-2.png" alt="截图-2" /></p>
</li>
<li>
<p>使用 schema 约束 xml，要指定自定义 schema 文件的 namespace，同时还要使用 schemaLocation 属性指自定义 schema 文件的位置，但是 schemaLocation 属性由 w3c 提供，所以这里还需要再引入一个提供 schemaLocation 属性的 schema，引用多个 schema 需要起不同的别名以区分，下面使用 schemaLocation 时前面加上别名。<br />
<img src="media/15784034414028/%E6%88%AA%E5%9B%BE.png" alt="截图" /></p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16262572235369.html">字节</a></h1>
			<p class="meta"><time datetime="2021-07-14T18:07:03+08:00" 
			pubdate data-updated="true">2021/07/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E4%B8%80%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一面</h2>
<p>手撕：LRU</p>
<ol>
<li>硕士期间做的东西</li>
<li>Netty 相关（线程模型、底层是用的 epoll 吗、EventLoopGroup 线程数量怎么设置的、用了几个 Group 分别是干嘛的、拆包黏包是什么、有哪些解决方案）</li>
<li>消息分级如何实现的、会不会造成饥饿现象、怎么优化（使用 Java 优先级队列可不可以、可以用多个队列随机选一个、MQ）</li>
<li>隔离级别</li>
<li>MVCC</li>
<li>间隙锁</li>
<li>select/poll/epoll</li>
<li>什么是 MPI</li>
<li>乐观锁、悲观锁</li>
<li>CAS、有什么问题</li>
<li>Http2.0 的改进</li>
<li>Https 如何保证安全</li>
</ol>
<h2><a id="%E4%BA%8C%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二面</h2>
<p>全程项目</p>
<ol>
<li>项目挑战，如何解决的？</li>
<li>如何充分发挥dtu并发性，（异步）</li>
<li>轮询如何优化（不用信号通知的机制，可能通知会丢失，每次轮训睡眠1s，以稍高负载换取代码简洁性以及更少的业务逻辑）</li>
<li>验证装置如何设计的？（为了避免当作机器人被屏蔽设置随机时间）</li>
<li>如何看待后端开发业务和目前的研究生方向？</li>
<li>手撕：一个用户登录表（userid, login_time, logout_time），量很大，查找这一天的峰值人数和持续时间？</li>
</ol>
<pre><code class="language-c">//当天数据容器
var array = new int[24];
//初始化数据
foreach (var item in logs) {
    //只记录当前在线人数即可
    for (int i = item.LoginTime; i &lt; item.LogoutTime; i++) {
        array[i]++;
    }
}
 
//统计部分
int biggest = 0;        //峰值
int biggestLength = 0;  //持续时长
int biggestTime = 0;    //最大开始时间
 
for (int i = 0; i &lt; array.Length; i++) {
    //当前在线人数
    var currentValue = array[i];
    
    //存储最大峰值
    if (currentValue &gt; biggest) {
        biggest = currentValue;
        biggestLength = 0;
        biggestTime = i;
    }
    
    if (currentValue == biggest)
        biggestLength++;
}
</code></pre>
<ol>
<li>反馈：思考问题需要有更多的层次，有时回答的很多点本质上都是一样的。（潜台词思维不够发散）</li>
</ol>
<h2><a id="%E4%B8%89%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三面</h2>
<ol>
<li>介绍研究生的课题</li>
<li>介绍一个项目，背景、挑战等，负责哪部分</li>
<li>webservice 原理</li>
<li>tcp 建立连接的过程（三次握手、四次挥手）、tcp 传输的内容（除了那几个标志位）、有抓过包吗？有什么工具？</li>
<li>java 的锁、什么是自旋锁、如何实现自旋锁、哪些场景会用到自旋锁？</li>
<li>hashmap 源码、为什么从 jdk1.8 从 entry 变成了 node、扩容为什么是 2 倍、扩容因子怎么确定的、默认是多少？</li>
<li>算法题：最长回文子串</li>
<li>反馈：要知其然还要知其所以然，理论联系实际还不够</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16251512388574.html">字节飞书面经</a></h1>
			<p class="meta"><time datetime="2021-07-01T22:53:58+08:00" 
			pubdate data-updated="true">2021/07/01</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#other">other</a></li>
</ul>
</div>
<h2><a id="1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1</h2>
<ol>
<li>
<p><del>了解设计模式吗？实现下单例模式</del></p>
<blockquote>
<p>4种（<a href="16227359619314.html">单例模式</a>）</p>
</blockquote>
</li>
<li>
<p><del>MySQL用过吗，出现过什么问题，怎么解决的？</del></p>
<blockquote>
<p>索引失效（先试用explain分析性能，查看这条语句扫描了多少数据，如果感觉扫描的数据明显很多，就考虑是不是索引失效问题，针对单列查询，不要把索引放在表达式里，对于多列索引，如果有范围查找或like，那么后面的索引就会失效），此外，在多列索引里尽量让区分度大的索引放在前面，还要尽量建立覆盖索引，减少回表</p>
</blockquote>
</li>
<li>
<p><del>说说MySQL的存储引擎有什么，有什么区别</del></p>
<blockquote>
<p>事务、锁粒度、索引、热备份、故障恢复</p>
</blockquote>
</li>
<li>
<p><del>用过事务吗，说说他的隔离级别</del></p>
</li>
<li>
<p><del>当前读和快照读的区别</del></p>
<blockquote>
<p>当前读（insert、update、delete、select for update）加锁，快照读（select）不加锁</p>
</blockquote>
</li>
<li>
<p>Redis怎么用的？</p>
<blockquote>
<p>计数器string、缓存kv、消息队列list、交集并集实现共同好友、分布式锁</p>
</blockquote>
</li>
<li>
<p>说说Redis的持久化机制？</p>
<blockquote>
<p>RDB快照/AOF追加，三种追加备份时机</p>
</blockquote>
</li>
<li>
<p>epoll select poll区别</p>
<blockquote>
<p><a href="16251055746690.html">select &amp; poll &amp; epoll</a></p>
</blockquote>
</li>
<li>
<p>说说ET和LT的区别</p>
</li>
<li>
<p><del>说说tcp拥塞控制</del></p>
</li>
<li>
<p><del>Linux常见命令认识哪些</del></p>
</li>
<li>
<p><del>说说软连接，硬链接，目录能不能用硬链接</del></p>
<blockquote>
<p>软-符号链接，他有自己的 inode，内容指向真正的路径，删了原文件，就不能用了；硬和原文件使用同一个inode，只是引用计数+1，删除原文件不影响，只是计数-1，计数是0才真正删除；目录不能用硬连接</p>
</blockquote>
</li>
<li>
<p>用过什么信号，说几个常见的</p>
<blockquote>
<p>信号量semaphore、条件变量condition、互斥锁mutex</p>
</blockquote>
</li>
<li>
<p>了解协程吗？跟线程进程有什么区别</p>
<blockquote>
<p>协程是一个线程在执行一个函数的时候可以随时打断去执行另一个程序，然后再返回来继续执行，有点类似CPU的中断，所以协程看起来很像多个线程同时执行。<br />
区别：协程发生在用户态不需要线程的上下文切换，效率极高；由于是同一个线程，不存在死锁竞争的问题；协程适用于被阻塞的，且需要大量并发的场景，但不适用于大量计算</p>
</blockquote>
</li>
<li>
<p><del>说说死锁，产生条件，怎么解决</del></p>
</li>
</ol>
<h2><a id="2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2</h2>
<ol>
<li>
<p><del>堆排序、插入、删除怎么实现</del></p>
</li>
<li>
<p><del>并查集是什么</del></p>
</li>
<li>
<p>跳表是什么？怎么实现？</p>
<p>当原始链表中元素数量足够大，且抽取足够随机的话，我们得到的索引是均匀的。随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引。在每次新插入元素的时候，尽量让该元素有 1/2 的几率建立一级索引、1/4 的几率建立二级索引、1/8 的几率建立三级索引，以此类推，当建立二级索引的时候，同时也会建立一级索引；当建立三级索引时，同时也会建立一级、二级索引。</p>
</li>
<li>
<p><del>树的四种遍历方式？具体怎么实现？</del></p>
</li>
<li>
<p><del>mysql四种隔离机制有哪几种？</del></p>
</li>
<li>
<p><del>mysql如何解决幻读？</del></p>
</li>
<li>
<p><del>当前读和快照读的区别</del></p>
</li>
<li>
<p><del>mvcc怎么实现？</del></p>
</li>
<li>
<p><del>java锁有什么？具体说明</del></p>
</li>
<li>
<p><del>redolog,undolog的区别</del></p>
</li>
<li>
<p><a href="%5B%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%5D(16251589620596.html)">redis的缓存雪崩、击穿、穿透</a></p>
</li>
<li>
<p>[redis的字符串具体实现](<a href="mweblib://16251605590461">Redis 字符串</a>)</p>
</li>
<li>
<p><del>布隆过滤器的实现原理</del></p>
</li>
<li>
<p>设计一个酒店管理系统，写出er图。</p>
</li>
</ol>
<h2><a id="3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3</h2>
<ol>
<li>
<p><del>简单介绍一下线程池吗（七大参数，四大类型）</del></p>
</li>
<li>
<p>线程池的核心线程数大小如何确定（计算密集型为 N+1，IO密集型为 2N）</p>
<blockquote>
<p><strong>线程数=cpu可用核心数/（1-阻塞系数）</strong>，其中阻塞系数的取值在[0,1]之间。计算密集型任务的阻塞系数为0，而IO密集型任务的阻塞系数则接近1。一般，我们让线程执行的任务是比较复杂的，不会是单一的计算密集型任务，或者单一的IO密集型任务，通常会夹杂着。那么就需要我们去计算阻塞系数了。阻塞系数的定义就是执行该任务阻塞的时间与（阻塞时间+计算时间）的比值，也就是w/(w+c)。<br />
一般经验： IO密集型：2倍cpu可用线程数；计算密集型：cpu可用核数</p>
</blockquote>
</li>
<li>
<p>项目里面的定时任务怎么实现，如果定时五分钟，但是有一个任务需要六分钟才能执行完如何处理</p>
<blockquote>
<p>任务里面新开线程？</p>
</blockquote>
<pre><code class="language-java">new Timer().schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}, 0, 3000);
</code></pre>
</li>
<li>
<p>10亿个数字，2G内存，里面怎么找最大值</p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903519640616967">https://juejin.cn/post/6844903519640616967</a></p>
</blockquote>
</li>
<li>
<p>缓存了解吗，说一说本地缓存和分布式缓存都有哪些，有什么特点和区别</p>
<blockquote>
<p>本地缓存: 使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p>
</blockquote>
<blockquote>
<p>分布式缓存: 使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p>
</blockquote>
</li>
<li>
<p>讲一下cookies和session区别</p>
</li>
<li>
<p>怎么保证cookies不被劫持</p>
<blockquote>
<ul>
<li>给Cookie添加HttpOnly属性, 这种属性设置后, 只能在http请求中传递, 在脚本中, document.cookie无法获取到该Cookie值. 对XSS的攻击, 有一定的防御值. 但是对网络拦截, 还是泄露了.</li>
<li>在cookie中添加校验信息, 这个校验信息和当前用户外置环境有些关系,比如ip,user agent等有关. 这样当cookie被人劫持了, 并冒用, 但是在服务器端校验的时候, 发现校验值发生了变化, 因此要求重新登录, 这样也是种很好的思路, 去规避cookie劫持.</li>
<li>cookie中session id的定时更换, 让session id按一定频率变换, 同时对用户而言, 该操作是透明的, 这样保证了服务体验的一致性.</li>
</ul>
</blockquote>
</li>
<li>
<p>TCP和UDP说一下</p>
</li>
<li>
<p>TCP三次握手</p>
</li>
<li>
<p>TCP的可靠性如何实现</p>
<blockquote>
<p>应答机制、重传机制、流量控制、拥塞控制</p>
</blockquote>
</li>
<li>
<p>如果接受到三次ACK都没信号，直接断开连接行吗，会发生什么？</p>
</li>
<li>
<p>布隆过滤器说一下原理</p>
</li>
<li>
<p>说一下HashMap和Hashtable、ConcurrentMap的区别</p>
</li>
<li>
<p>为什么HashMap的容量一定是2的次方</p>
<blockquote>
<p>便于数据重新hash快速找到新的位置</p>
</blockquote>
</li>
<li>
<p>红黑树说一下，跳表说一下，那你知道什么地方用了红黑树和跳表吗</p>
</li>
<li>
<p>sql里面索引了解吗，分为哪些索引，能具体聊聊吗</p>
</li>
<li>
<p>MVCC的隔离机制，原子性怎么实现的，隔离性呢，一致性呢</p>
</li>
<li>
<p>Redis数据库和缓存一致性怎么保证 (<a href="https://segmentfault.com/a/1190000039078249">https://segmentfault.com/a/1190000039078249</a>)</p>
<blockquote>
<p>更新 DB，然后直接删除 cache 。如果删除 cache 失败</p>
<ul>
<li>缓存失效时间变短（不推荐，治标不治本） ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li>增加 cache 更新重试机制（常用）： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ul>
</blockquote>
</li>
<li>
<p>你知道Redis里面session共享有几种实现方式吗</p>
</li>
<li>
<p>JVM里面的几个区域，说一下GC的触发条件</p>
</li>
<li>
<p>如果我不断发生OOM，如何排查</p>
<blockquote>
<p><a href="16248673414388.html">OOM</a></p>
</blockquote>
</li>
<li>
<p>知道类加载过程吗，加载器有几种，什么时候舍弃双亲委派</p>
</li>
<li>
<p>数据库用的是Mysql吗，数据库的锁有哪些，数据库的死锁是什么，产生条件，如何避免</p>
</li>
<li>
<p>数据库的三大范式</p>
</li>
<li>
<p>如何实现一个可靠UDP</p>
<blockquote>
<p>送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
</blockquote>
</li>
<li>
<p>了解Linux什么命令</p>
</li>
<li>
<p>那ping命令是什么协议</p>
</li>
<li>
<p>top命令有哪些参数，说一下<br />
<img src="media/16251512388574/16254130733963.jpg" alt="" class="mw_img_center" style="width:611px;display: block; clear:both; margin: 0 auto;" /></p>
</li>
<li>
<p>用linux搭建过测试环境吗，用过什么ssh连接工具</p>
</li>
<li>
<p>你能说一下了解哪些网络错误码吗</p>
</li>
<li>
<p>Lock和synchronized有什么区别，自旋和轻量级锁有什么区别，自己debug看过吗</p>
</li>
<li>
<p>ThreadLocal 的原理和适用场景知道吗</p>
<blockquote>
<p>每个线程内部有个 ThreadLocal.ThreadLocalMap 变量, 里面定义了Entry 来保存数据。key 就是我们声明的 threadlocal 变量。<br />
相当于我们使用的还是 线程本身提供的 threadlocalMap，只是使用 threadlocal 作为调用入口。<br />
ThreadLocal是一个弱引用，当为null时，会被当成垃圾回收。所以有可能 ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。</p>
</blockquote>
</li>
<li>
<p>四种引用知道吗，三色法又是什么</p>
<blockquote>
<p>可达性分析时，把遍历对象图过程中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li>白色：尚未访问过。</li>
<li>本对象已访问过，而且本对象引用到的其他对象也全部访问过了。</li>
<li>本对象已访问过，但是本对象引用到的其他对象尚未全部访问完。全部访问后，会转换为黑色。</li>
</ul>
</blockquote>
<blockquote>
<p>初始时，所有对象都在【白色集合】中；<br />
将 GC Roots 直接引用到的对象挪到 【灰色集合】中；<br />
从灰色集合中获取对象：</p>
<ul>
<li>将本对象引用到的其他对象全部挪到 【灰色集合】中；</li>
<li>将本对象挪到【黑色集合】里面。</li>
</ul>
</blockquote>
</li>
<li>
<p>TreeMap底层说一下</p>
<blockquote>
<p>底层使用红黑树实现，实现了NavigableMap接口和SortedMap 接口。相比于HashMap，有了对集合内元素的搜索和排序的能力。</p>
</blockquote>
</li>
</ol>
<h2><a id="4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4</h2>
<ol>
<li>
<p><del>线程和进程的区别</del></p>
</li>
<li>
<p>既然你说到线程切换上下文开销比进程大，为什么？</p>
<blockquote>
<p>进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。虚拟空间需要查页表，很慢。</p>
</blockquote>
</li>
<li>
<p>操作系统父进程执行fork()命令，假如父进程拥有1G的资源，那么子进程会携带这些资源吗？</p>
<blockquote>
<p>不会。fork 执行时并不真正复制用户空间的所有页面，而只是复制页面表。这样，无论父进程还是子进程，当发生用户空间的写操作时，都会引发“写复制”操作，而另行分配一块可用的用户空间，使其完全独立。<br />
vfork 也是创建一个子进程，但是子进程共享父进程的空间，过时了。<br />
clone 不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等。</p>
</blockquote>
</li>
<li>
<p>给你10000个IP，你如何快速查找这个IP是否存在，使用什么数据结构?</p>
</li>
<li>
<p>说到平衡树，随便给你一个数据类型的一组数据，怎么去构建平衡树。</p>
<blockquote>
<p>LL RR LR RL旋转</p>
</blockquote>
</li>
<li>
<p>B+树的特点有哪些？</p>
</li>
<li>
<p>既然你说到叶子节点通过指针连接，为什么呢？</p>
</li>
<li>
<p>这些叶子的存储页距离是相近的吗？是的，尽量保证相邻叶子所在页相近。</p>
</li>
<li>
<p>TCP连接过程，如何实现拥塞控制？</p>
</li>
<li>
<p>还了解哪些构造索引的数据结构？</p>
<blockquote>
<p>哈希：查找快，无法排序和范围查找<br />
平衡二叉树：树高、范围查找需要回旋<br />
B 树：树低，但没有解决查找问题<br />
B+ 树：叶子节点有指针相连，范围查找效率高</p>
</blockquote>
</li>
<li>
<p>使用哈希表作为索引有哪些？忘记Memcache还有Redis是使用这个。。。害</p>
</li>
<li>
<p>new 在生成对象的时候发生了什么？默认虚拟机类加载完成时，类的信息保存在哪里？怎么找到的？</p>
</li>
<li>
<p>StringBuilder 和 StringBuffer 的差别</p>
<blockquote>
<p>StringBuffer和StringBuilder类长度是可以改变的；<br />
StringBuffer类是线程安全的，StringBuilder不是线程安全的;<br />
StringBuffer的append的方法都被toStringCache关键字修饰了, 加了锁，效率差一些</p>
</blockquote>
</li>
<li>
<p>jvm 的线程状态有几种？</p>
</li>
</ol>
<p><img src="media/16251512388574/16261060643956.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;" /></p>
<ol start="11">
<li>
<p>sleep() 方法如何被打断。</p>
<blockquote>
<p>通过interrupt方法打断sleep。这时会出一个InterruptedException异常。</p>
</blockquote>
</li>
<li>
<p>运行态为什么会变成阻塞态？</p>
<blockquote>
<p>获取不到锁</p>
</blockquote>
</li>
<li>
<p>wait()对应的notify()和notifyAll()有什么区别？</p>
</li>
<li>
<p>数据库行转列 name, subject, score</p>
<pre><code class="language-sql">SELECT 
t.`姓名` AS `姓名`, 
MAX(CASE WHEN t.`课程`='语文' THEN t.`成绩` END) AS `语文`, 
MAX(CASE WHEN t.`课程`='数学' THEN t.`成绩` END) AS `数学`, 
MAX(CASE WHEN t.`课程`='英语' THEN t.`成绩` END) AS `英语` 
FROM csdnTest t 
GROUP BY t.姓名
</code></pre>
<p>列转行</p>
<pre><code class="language-sql">SELECT
    NAME,
    '语文' AS subject ,
    MAX(&quot;语文&quot;) AS score
FROM student1 GROUP BY NAME
UNION
SELECT
    NAME,
    '数学' AS subject ,
    MAX(&quot;数学&quot;) AS score
FROM student1 GROUP BY NAME
UNION
SELECT
    NAME,
    '英语' AS subject ,
    MAX(&quot;英语&quot;) AS score
FROM student1 GROUP BY NAME
</code></pre>
</li>
</ol>
<p>正常情况下，一个学生对应一个课程只有一个分数，因此可以使用SUM()、MAX()、MIN()、AVG()等聚合函数都可以达到行转列的效果。</p>
<ol>
<li>
<p>delete和truncate的区别有哪些？</p>
<blockquote>
<p>DELETE删除一行，作为事务记录在日志中便进行进行回滚操作。TRUNCATE TABLE 从表中删除所有的数据,不记入日志保存<br />
Truncate table 表名速度快效率高,因为使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。<br />
Truncate 自增主键重置；DELETE会保留</p>
</blockquote>
</li>
<li>
<p>DDL 和 DML的区别？</p>
</li>
<li>
<p>有五六十个T的一张表，内存2G，表里只有两个字段（用户名、所在城市），如何找出在广东的那些？</p>
</li>
<li>
<p>64批马，有一条赛道，每次比赛只能8批马进行赛跑，最小次数找出最快的4批？</p>
</li>
<li>
<p>linux玩的怎么样？</p>
</li>
<li>
<p>我想知道CPU使用率最高的4个进程？<br />
ps aux 获取所有进程，grep -v PID 将标题去掉，sort -rn -k +3 中 -rn 的 r 表示是结果倒序排列，n 为以数值大小排序，而-k +3则是针对第3列的内容进行排序，再使用head命令获取默认前10行数据。</p>
<blockquote>
<p>ps aux|grep -v PID|sort -rn -k +3|head<br />
top，按 M 是查看cpu占用，P查看内存占用</p>
</blockquote>
</li>
<li>
<p>如何统计文本字符串行数？</p>
<blockquote>
<p>wc -l</p>
</blockquote>
</li>
<li>
<p>vi编辑器中如何找出特定字符串的行？</p>
</li>
</ol>
<h2><a id="other" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>other</h2>
<ol>
<li>
<p>数据库主从复制怎么实现？是通过执行sql还是事务来实现主从复制？有几种方式？</p>
</li>
<li>
<p>内存交换和虚拟内存的区别</p>
</li>
<li>
<p>HTTP1.1和2.0的区别</p>
</li>
<li>
<p>Redis 数据结构</p>
</li>
<li>
<p>物理地址、虚拟地址、逻辑地址</p>
<blockquote>
<p>虚拟地址: 指由程序产生的由段选择符和段内偏移地址组成的地址。<br />
逻辑地址: 指由程序产生的段内偏移。有时候直接把逻辑地址当做虚拟地址。<br />
物理地址: 指CPU外部地址总线上寻址物理内存的地址信号，是地址变换的最终结果。</p>
</blockquote>
</li>
<li>
<p>数据库三大范式</p>
</li>
<li>
<p>双亲委派模型，什么时候需要打破</p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16290200093355.html">Java 基础</a></h1>
			<p class="meta"><time datetime="2021-08-15T17:33:29+08:00" 
			pubdate data-updated="true">2021/08/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#pacake">Pacake</a></li>
<li><a href="#%E8%BE%93%E5%85%A5">输入</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%B1%BB">常用类</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6">字符</a></li>
<li><a href="#%E6%95%B0%E5%AD%A6">数学</a></li>
<li><a href="#%E9%98%B2%E6%AD%A2%E6%BA%A2%E5%87%BA">防止溢出</a></li>
</ul>
</div>
<h2><a id="pacake" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pacake</h2>
<pre><code class="language-java">import java.util.*;
import java.lang.*;
</code></pre>
<h2><a id="%E8%BE%93%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>输入</h2>
<pre><code class="language-java">Scanner in = new Scanner(System.in);
/*
 * 第一行 n 代表下面有 n 行
 * 2
 * 1 2 3 4
 * 2 4 52
 */
int n = in.nextInt();
in.nextLine(); // 把上一行 nextInt 后遗留的 \n 读取掉
while (n &gt; 0) {
    String line = in.nextLine();
    System.out.println(line);
    n--;
}

/*
 * 直接给定 n 行，空行结束
 * 1 2 3 4
 * 2 4 52
 *
 */
while (in.hasNextLine()) { // 获得换行前输入的内容
    String line = in.nextLine();
    if (line.equals(&quot;&quot;)) break;
    System.out.println(line);
}
</code></pre>
<h2><a id="%E5%B8%B8%E7%94%A8%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用类</h2>
<ol>
<li>List
<pre><code class="language-java">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
// 增
list.add(1);
list.add(0, 0); // 向第 0 位插入元素
Collections.addAll(list, xxx); // 将 xxx 追加到 list
// 查
list.get(0); // 查
list.size();
list.isEmpty();
// 改
list.set(0, 5);
// 删
list.remove(0); // 删
list.clear();

list.subList(0, 1); // 获取子数组 [0, 1)

// 数组 -&gt; list
 Collections.addAll(list, Integer[]); // 不能是 int[]
 Arrays.asList(Integer[]); // 这样转换的 list 不能增删，只能查改
</code></pre>
</li>
<li>Map
<pre><code class="language-java">// Map
Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
// 增，修改
map.put(1, 2);
// 删
map.remove(1);
map.clear();
// 查
map.get(1);
map.getOrDefault(1, xxx); // 找不到就设置成 xxx
map.containsKey(1); // 判断 key 是否存在
map.containsValue(3); // 判断 value 是否存在
map.size();
map.isEmpty();
// 遍历
Set&lt;Integer&gt; keys = map.keySet();// 获取 key 组成的 set
Collection&lt;Integer&gt; values = map.values();// 获取 value 组成的 collection
</code></pre>
</li>
<li>Set
<pre><code class="language-java">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
// 增
set.add(1);
// 删
set.remove(1);
set.clear();
// 查
set.contains(1);
set.size();
set.isEmpty();
</code></pre>
</li>
<li>Stack
<pre><code class="language-java">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
// 入栈
stack.push(1);
// 出栈
stack.pop();
stack.clear();
// 查看
stack.peek();
stack.isEmpty();
stack.size();
</code></pre>
</li>
<li>Queue &amp; PriorityQueue
<pre><code class="language-java">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(); // 方法与 LinkedList 相同
// 入队
queue.offer(1);
// 出队
queue.poll();
queue.clear();
// 查看
queue.peek();
queue.isEmpty();
queue.size();
</code></pre>
</li>
<li>深拷贝
<pre><code class="language-java">int[] i1 = {1, 2};
int[] clone = i1.clone();

ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
ArrayList&lt;Integer&gt; clone1 = (ArrayList&lt;Integer&gt;) list.clone();

HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();
HashMap&lt;Integer, Integer&gt; clone2 = (HashMap&lt;Integer, Integer&gt;) hashMap.clone();
</code></pre>
</li>
</ol>
<h2><a id="%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>排序</h2>
<pre><code class="language-java">// list 排序
ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
// add...
Collections.sort(list); // 正序
Collections.sort(list, Comparator.reverseOrder()); // 逆序

// 复杂对象排序
ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();
// add...
Collections.sort(users, (User a, User b) -&gt; {
    return a.age - b.age; // 根据年龄排序
});

// 数组排序
int[][] is = new int[][]{{1, 2}, {2, 1}};
Arrays.sort(is, (int[] a, int[] b) -&gt; {
    return a[1] - b[1]; // 根据第 2 个元素排序
});
</code></pre>
<h2><a id="%E5%AD%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符</h2>
<pre><code class="language-java">String str = &quot;hello world!&quot;;
str.length(); // 获取长度
char[] chars = str.toCharArray(); // 转成 char 数组
str.charAt(1); // 通过索引获取字符
int i = Integer.parseInt(&quot;6&quot;); // 字符 -&gt; 数字
char c = (char) 66; // 数字 -&gt; char
String substr = str.substring(0, 6); // 截取
</code></pre>
<h2><a id="%E6%95%B0%E5%AD%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数学</h2>
<pre><code class="language-java">Integer.MAX_VALUE // 最大整数
Integer.MIN_VALUE // 最小整数
Collections.max(list); // 集合最大值
Arrays.stream(i).min().getAsInt(); // 数组最小值
Math.min(a, Math.min(b, c)) // 比较三个数大小，效率高
</code></pre>
<h2><a id="%E9%98%B2%E6%AD%A2%E6%BA%A2%E5%87%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>防止溢出</h2>
<pre><code class="language-java">% 1000000007
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16265229592142.html">海量数据算法</a></h1>
			<p class="meta"><time datetime="2021-07-17T19:55:59+08:00" 
			pubdate data-updated="true">2021/07/17</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射）</p>
</blockquote>
<h2><a id="%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8Bhash%E6%98%A0%E5%B0%84-hash-map%E7%BB%9F%E8%AE%A1%E5%A0%86%E5%BF%AB%E9%80%9F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序</h2>
<ol>
<li>
<p><strong>海量日志数据，提取出某日访问百度次数最多的那个IP</strong></p>
<ul>
<li>hash 映射，相同的ip分到同一个块</li>
<li>各个块内使用 hash map 统计</li>
<li>对各个 hashmap 最大的那个进行排序，得到答案</li>
</ul>
</li>
<li>
<p><strong>寻找热门查询，300万个查询字符串中统计最热门的10个查询（重复度比较高）</strong><br />
由于有重复，可以直接使用 hashmap 完全放入内存统计，然后排序</p>
</li>
<li>
<p><strong>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</strong><br />
hash 映射 + hashmap 统计 + 排序</p>
</li>
<li>
<p><strong>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10</strong></p>
<ul>
<li>遍历一遍数据，重新 hash 分配，使得同一数据存在同一机器</li>
<li>每个机器求出 top 10，把所有的结果文件再进行 top10</li>
</ul>
</li>
<li>
<p><strong>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序</strong></p>
<ul>
<li>重新分配到 10 个文件</li>
<li>对每个文件分别 hashmap 统计，把结果排序</li>
<li>对 10 个排好序的结果进行归并排序</li>
</ul>
</li>
<li>
<p><strong>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</strong></p>
<ul>
<li>对 a hash映射到1000个小文件 [a1,a2...a1000]，对 b 也这样做[b1,b2...b1000]，这样所有可能共同的 url 都在同一个编号的小文件中，比如 a1 vs b1</li>
<li>把 a1 文件 url 存到 hashset，遍历 b1，对比 hashset，重复 1000 遍比较完所有文件</li>
</ul>
</li>
</ol>
<h2><a id="%E5%A4%9A%E5%B1%82%E5%88%92%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多层划分</h2>
<ol>
<li><strong>5亿个int找它们的中位数。</strong>
<ul>
<li>将这些数据按照分界值划分到多个桶里面，桶之间是有顺序的，桶内无序</li>
<li>分别统计每个桶里的数据，找出中位数落在哪一个桶里，并且找出在这个桶里排序后位置k</li>
<li>重复上述划分-查找的过程，直到桶里的数据可以完全载入内存查找</li>
</ul>
</li>
</ol>
<h2><a id="bloom-filterbitmap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bloom filter/Bitmap</h2>
<ol>
<li>
<p><strong>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</strong></p>
<ul>
<li>每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义，共1GB内存</li>
<li>然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。</li>
<li>查看bitmap，把对应位是01的整数输出</li>
</ul>
</li>
<li>
<p><strong>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</strong></p>
<ul>
<li>申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位</li>
<li>读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</li>
</ul>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16262426905528.html">常见题</a></h1>
			<p class="meta"><time datetime="2021-07-14T14:04:50+08:00" 
			pubdate data-updated="true">2021/07/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E5%87%A0%E6%95%B0%E4%B9%8B%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>几数之和</h2>
<p><a href="https://leetcode-cn.com/problems/two-sum">1.两数之和</a> （哈希）<br />
<a href="https://leetcode-cn.com/problems/3sum">15.三数之和</a> （排序 + 二分查找）</p>
<h2><a id="%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>子序列 &amp; 子串</h2>
<h3><a id="dp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>dp</h3>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray">53.最大子序和</a>、<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a><br />
<a href="https://leetcode-cn.com/problems/edit-distance">72.编辑距离</a><br />
<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300.最长递增子序列</a> -&gt; <a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354.俄罗斯套娃信封问题</a> （优化：贪心+二分查找）<br />
<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143.最长公共子序列</a> -&gt; <a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583.两个字符串的删除操作</a> -&gt; <a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">712.两个字符串的最小ASCII删除和</a><br />
<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">516.最长回文子序列</a><br />
<a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/submissions/">1312.让字符串成为回文串的最少插入次数</a></p>
<h3><a id="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>滑动窗口</h3>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">3.无重复最长子串</a><br />
<a href="https://leetcode-cn.com/problems/minimum-window-substring">76.最小覆盖子串</a><br />
<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a><br />
<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a> （交替滑动）</p>
<h3><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h3>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a> （中心扩散）<br />
<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560.和为 K 的子数组</a> （前缀和 + hash）<br />
<a href="https://leetcode-cn.com/problems/shortest-palindrome/">214.最短回文串</a> （字符串哈希）<br />
<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128.最长连续序列</a> （哈希set）<br />
<a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410.分割数组的最大值</a> （二分查找）</p>
<h2><a id="%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%AD%90%E9%9B%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>排列 &amp; 组合 &amp; 子集</h2>
<h3><a id="%E5%AD%90%E9%9B%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>子集</h3>
<p>求数组所有子集：递归回溯</p>
<pre><code class="language-java">// 注意 i 从 start 开始递增
for (int i = start; i &lt;= n; i++) {
    // 回溯 ...
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">698.划分为k个相等的子集</a></p>
<h3><a id="%E7%BB%84%E5%90%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组合</h3>
<p>输出 [1..n] 中 k 个数字的所有组合：递归回溯 + 剪枝：传入一个 start 参数，来排除 start 索引之前的数字</p>
<pre><code class="language-java">// 剪枝
if (k == track.size()) {
    res.push_back(track);
    return;
}
// 注意 i 从 start 开始递增
for (int i = start; i &lt;= n; i++) {
    // 回溯 ...
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40.组合总数II</a>，改题目的关键在于如何去重：先排序，然后在同一层次内（<code>i &gt; idx</code>）不添加相同的数字（<code>candidates[i-1] == candidates[i]</code>）</p>
<pre><code class="language-py">def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:
    candidates.sort() # 排序
    n = len(candidates)
    res = []
    def helper(s, path, idx):
        if s == target: 
            res.append(path[:])
            return
        
        for i in range(idx, n):
            if s + candidates[i] &gt; target: break
            if i &gt; idx and candidates[i-1] == candidates[i]: continue # 去重
            path.append(candidates[i])
            helper(s + candidates[i], path, i + 1)
            path.pop()
    
    helper(0, [], 0)
    return res
</code></pre>
<h3><a id="%E6%8E%92%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>排列</h3>
<p>求数组的所有排列：回溯，通过 contains 方法来排除在 track 中已经选择过的数字</p>
<pre><code class="language-java">for (int i = 0; i &lt; nums.length; i++) {
    // 排除不合法的选择
    if (track.contains(nums[i])) continue;
    // 回溯 ...
}
</code></pre>
<p>方法二：原地交换数组顺序，当前正在排第几个，就把需要遍历的交换到这里，代表这个位置之前的都已经在路径中，就不需要在使用 contains 判断</p>
<pre><code class="language-py">def helper(idx):
    if idx == n:
        res.append(nums.copy())
        return
    for i in range(idx, n):
        nums[i], nums[idx] = nums[idx], nums[i]
        helper(idx+1)
        nums[i], nums[idx] = nums[idx], nums[i]
</code></pre>
<h2><a id="%E8%83%8C%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背包</h2>
<p><a href="https://leetcode-cn.com/problems/word-break/solution/yi-tao-kuang-jia-jie-jue-bei-bao-wen-ti-kchg9/">一套框架解决「背包问题」</a></p>
<h3><a id="0-1%E8%83%8C%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0-1 背包</h3>
<p>通用状态方程： <code>dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i-1]] + val[i-1])</code>，代表使用前 i 个数组成 w</p>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a></p>
<pre><code class="language-py">def canPartition(self, nums: List[int]) -&gt; bool:
    sm = sum(nums)
    lm = len(nums)
    if sm &amp; 1 == 1: return False
    sm //= 2
    dp = [[True if j == 0 else False for j in range(sm + 1)] for i in range(lm + 1)]
    for n in range(1, lm+1):
        for s in range(1, sm+1):
            if s &lt; nums[n-1]: dp[n][s] = dp[n-1][s]
            else: dp[n][s] = dp[n-1][s] or dp[n-1][s-nums[n-1]]
    return dp[lm][sm]
</code></pre>
<p>状态压缩：由于 <code>dp[i]</code> 只依赖上一行的 <code>dp[i-1]</code>，可以状态压缩成一维：<code>dp[j] = dp[j] | dp[j-nums[i]]</code>，注意为了不覆盖上一行数据，需要倒序遍历 dp</p>
<pre><code class="language-py">def canPartition(self, nums: List[int]) -&gt; bool:
    n = len(nums)
    s = sum(nums)
    if s &amp; 1 == 1: return False
    target = s // 2
    dp = [False for _ in range(target + 1)]
    dp[0] = True
    for i in range(n):
        num = nums[i]
        for j in range(target, num - 1, -1): # 倒序
            dp[j] = dp[j] or dp[j-num]

    return dp[-1]
</code></pre>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a><br />
因为 <code>target = x - y， sum = x + y</code> 所以 <code>x = (sum + target) // 2</code>，转化成分割子集问题</p>
<pre><code class="language-py">def findTargetSumWays(self, nums: List[int], target: int) -&gt; int:
    # target = x - y
    # sum = x + y
    # x = (sum + target) // 2

    n = len(nums)
    x = target + sum(nums)
    if target &gt; sum(nums) or x &amp; 1 == 1: return 0
    x = x // 2
    dp = [0 for _ in range(x + 1)]
    dp[0] = 1

    for n in nums:
        for j in range(x, n-1, -1):
            dp[j] = dp[j] + dp[j-n]
    
    return dp[-1]
</code></pre>
</li>
</ul>
<h3><a id="%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完全背包</h3>
<p><code>dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]</code>，状态方程和 0-1 不同的地方在于当选择了第 i 个物品时，那么这个物品由于是不限量的，所以前面的也必须可以选择这个物品，因此，<code>dp[i][j-coins[i-1]]</code> 里面不再是 <code>i-1</code>。<br />
0-1 背包一个物品只能选一次，所以如果选了这个物品，前面必然不能选这个物品，前面的物品只能是使用前 i-1 个物品组成。</p>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/coin-change-2">518.零钱兑换II</a></p>
<pre><code class="language-py">def change(self, amount: int, coins: List[int]) -&gt; int:
    n = len(coins)
    dp = [[1 if j == 0 else 0 for j in range(amount+1)] for i in range(n+1)]
    

    for i in range(1, n+1):
        c = coins[i-1]
        for j in range(1, amount+1):
            if j &gt;= c:
                dp[i][j] = dp[i-1][j] + dp[i][j-c]
            else:
                dp[i][j] = dp[i-1][j]
    
    return dp[n][amount]
</code></pre>
<p>状态压缩：更新 dp[i][j] 时，j 位置上依赖上一次的结果 dp[i-1][j]，i 位置上依赖本行刚刚计算过的值，因此可以压缩状态：<code>dp[i] = dp[i] + dp[i-num]</code>，但是需要正向遍历，这样才能保证在 i 行，使用的是前面计算过的值。</p>
<pre><code class="language-py">def change(self, amount: int, coins: List[int]) -&gt; int:
    dp = [0 for j in range(amount+1)]
    dp[0] = 1

    for c in coins:
        for i in range(c, amount+1):
            dp[i] = dp[i] + dp[i-c]
    
    return dp[-1]
</code></pre>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/word-break/">139.单词拆分</a><br />
可以转化为完全背包问题，但是需要考虑顺序问题，外层循环需要为 target ，内层循环为选择池 wordDict。dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成。</p>
<pre><code class="language-py">def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:
    n = len(s)
    dp = [False for _ in range(n+1)]
    dp[0] = True

    for i in range(1, n+1):
        for word in wordDict:
            size = len(word)
            if i &gt;= size and s[i-size: i] == word:
                dp[i] = dp[i] or dp[i-size]
    
    return dp[-1]
</code></pre>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377.组合总和 Ⅳ</a><br />
需要考虑顺序问题，注意内外层循环</p>
<pre><code class="language-py">def combinationSum4(self, nums: List[int], target: int) -&gt; int:
    n = len(nums)
    dp = [0 for _ in range(target+1)]
    dp[0] = 1

    for i in range(1, target+1):
        for n in nums:
            if i &gt;= n:
                dp[i] = dp[i] + dp[i-n]
    
    return dp[-1]
</code></pre>
</li>
</ul>
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<ul>
<li>
<p>0-1 背包<br />
即数组中的元素不可重复使用，外循环遍历 arrs，内循环遍历 target，且内循环倒序</p>
</li>
<li>
<p>完全背包</p>
<ul>
<li>即数组中的元素可重复使用并且不考虑元素之间顺序，arrs 放在外循环（保证 arrs 按顺序），target在内循环。且内循环正序。</li>
<li>如合问题需考虑元素之间的顺序，需将 target 放在外循环，将 arrs 放在内循环，且内循环正序。</li>
</ul>
</li>
</ul>
<h2><a id="%E8%82%A1%E7%A5%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>股票</h2>
<p>状态方程定义：<code>dp[i][k][0|1]</code>，表示第 i 天，操作 k 次，0 不持有股票，1 持有股票</p>
<p>框架：</p>
<pre><code class="language-py">dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = float('-inf')

dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
</code></pre>
<ul>
<li>
<p>只能买卖一次：省略 k</p>
<pre><code class="language-py">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
</code></pre>
</li>
<li>
<p>可以买卖任意次：省略 k</p>
<pre><code class="language-py">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
</code></pre>
</li>
<li>
<p>卖了之后隔一天才能交易：买的时候关注前天的利益</p>
<pre><code class="language-py">dp[i][k][1] = max(dp[i-1][k][1], dp[i-2][k-1][0] - prices[i])
</code></pre>
</li>
<li>
<p>有手续费：</p>
<pre><code class="language-py">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i] - fee)
</code></pre>
</li>
<li>
<p>限制交易次数：注意遍历 k</p>
</li>
</ul>
<h2><a id="%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打家劫舍</h2>
<ul>
<li>
<p>不能偷相邻的房屋：<code>dp[i] = max(dp[i-2] + nums[i-1], dp[i-1])</code></p>
</li>
<li>
<p>屋子围城一个圆，不能偷相邻房屋：分两种情况，偷 [0, n-1] 个房屋，偷 [1, n] 个房屋，找较大值</p>
</li>
<li>
<p>二叉树结构的房屋：递归遍历，如果偷某个结点，那么他的两个孩子结点都不能偷，如果不偷这个结点，可以选择两个孩子结点偷或不偷的较优值。返回给付结点这个结点偷或不偷两种情况的收益。</p>
<pre><code class="language-py">rob = root.val + l_n_rob + r_n_rob
n_rob = max(l_rob, l_n_rob) + max(r_rob, r_n_rob)
</code></pre>
</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16255578488940.html">质因子分解</a></h1>
			<p class="meta"><time datetime="2021-07-06T15:50:48+08:00" 
			pubdate data-updated="true">2021/07/06</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>质因子分解</h2>
<ul>
<li><code>i * i &lt;= n</code>，保证不会重复判断，防止超时</li>
<li>因为是从 2 开始分解的，2 的倍数也会循环分解，所以 i 是前面遍历过的数的倍数时，肯定是不会再分解的，直接跳过，例如 4 在前面分解 2 的时候第二次判断 %2 就已经是在判断 %4 了，就不用每次都判断是不是质数了。</li>
</ul>
<pre><code class="language-python">import sys

n = int(sys.stdin.readline().strip())
i = 2
while i * i &lt;= n and i &lt;= n:
    while n % i == 0:
        print(i, end=' ')
        n //= i
    i += 1

if n != 1:
    print(n, end=' ')
</code></pre>
<h2><a id="%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最小公倍数</h2>
<p>把两个数的所有不重复质因子相乘</p>
<h2><a id="%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最大公约数</h2>
<p>把两个数的所有公共质因子相乘</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16253942755012.html">LFU</a></h1>
			<p class="meta"><time datetime="2021-07-04T18:24:35+08:00" 
			pubdate data-updated="true">2021/07/04</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"></div>
<pre><code class="language-java">class LFUCache {
    
    HashMap&lt;Integer, Integer&gt; k2v;
    HashMap&lt;Integer, Integer&gt; k2f;
    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; f2ks;
    int minf;
    int capacity;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.minf = 0;
        this.k2v = new HashMap&lt;&gt;();
        this.k2f = new HashMap&lt;&gt;();
        this.f2ks = new HashMap&lt;&gt;();
    }
    
    public int get(int key) {
        if (!k2v.containsKey(key)) return -1; // 没有返回 -1
        increaseFreq(key); // 有则把频率 +1 返回
        return k2v.get(key);
    }
    
    public void put(int key, int value) {
        if (capacity &lt;= 0) return;
        if (k2v.containsKey(key)) { // 已存在，变更值并把频率 +1
            k2v.put(key, value);
            increaseFreq(key);
        } else {
            if (k2v.size() &gt;= capacity) { // 容量满了，需要删除一个
                removeMinFreqKey();
            }
            k2v.put(key, value);
            k2f.put(key, 1);
            f2ks.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); // 判断有没有频率是 1 的，没有先插入一个空节点
            f2ks.get(1).add(key); // 把 key 插入到频率是 1 的链表里
            minf = 1;
        }
    }

    public void increaseFreq(int key) {
        int freq = k2f.get(key);
        // 1. 维护 k2f
        k2f.put(key, freq + 1);

        // 2. 维护 f2ks
        f2ks.get(freq).remove(key); // 2.1 删除旧的
        if (f2ks.get(freq).isEmpty()) { // 删除旧的后，如果没有其他的 key 频率是 freq，把这个freq删除
            f2ks.remove(freq);
            if (minf == freq) minf++; // 刚好删除的 freq 就是目前最小的，那就更新一下
        }
        f2ks.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;());
        f2ks.get(freq + 1).add(key); // 2.2 插入新的
    }

    public void removeMinFreqKey() {
        LinkedHashSet&lt;Integer&gt; minFreqKeyList = f2ks.get(minf);
        int delKey = minFreqKeyList.iterator().next();
        // 1. 维护 f2ks
        minFreqKeyList.remove(delKey);
        if (minFreqKeyList.isEmpty()) {
            f2ks.remove(minf);
            // 不用更新 minf，因为删除后会插入新的 key，频率是 1
        }
        // 2. 维护 k2v
        k2v.remove(delKey);
        // 3. 维护 k2f
        k2f.remove(delKey);
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16224660155317.html">排序</a></h1>
			<p class="meta"><time datetime="2021-05-31T21:00:15+08:00" 
			pubdate data-updated="true">2021/05/31</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="py%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>py 内置函数</h2>
<h3><a id="sort-sorted" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>sort &amp; sorted</h3>
<pre><code class="language-python">list.sort() # 原地对 list 排序
another_list = sorted(list) # 返回一个新的 list
</code></pre>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义排序</h3>
<pre><code class="language-python"># 实现一个类，重载其中的__lt__函数 (实现 self 小于 s 的逻辑)
class Compare(str):
    def __lt__(self, s):
        return self + s &lt; s + self

# 传给 sort 或 sorted 的 key 参数
list.sort(key=Compare)
another_list = sorted(list, key=Compare)
</code></pre>
<h2><a id="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插入排序</h2>
<h3><a id="%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接插入</h3>
<p>时间复杂度：n^2<br />
空间复杂度：1<br />
稳定<br />
适用于顺序存储和链式存储</p>
<pre><code class="language-python">def insert_sort(elements):
    for i in range(1, len(elements)):
        if elements[i] &lt; elements[i-1]:
            tmp = elements[i]
            j = i - 1
            while j &gt;= 0 and elements[j] &gt; tmp:
                elements[j+1] = elements[j]
                j -= 1
            elements[j+1] = tmp
    return elements
</code></pre>
<h3><a id="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>希尔排序</h3>
<p>时间复杂度：当 n 在某个特定情况下，复杂度位 n^1.3，最坏为 n^2<br />
空间复杂度：O(1)<br />
不稳定<br />
仅试用顺序存储</p>
<pre><code class="language-python">def shell_sort(elements):
    n = len(elements)
    k = n // 2
    while k &gt;= 1: # 步长
        for i in range(k, n): # 排序每个子集
            if elements[i] &lt; elements[i - k]:
                tmp = elements[i]
                j = i - k
                while j &gt;= 0 and elements[j] &gt; tmp:
                    elements[j+k] = elements[j]
                    j -= k
                elements[j+k] = tmp

        k //= 2
    return elements
</code></pre>
<h2><a id="%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交换排序</h2>
<h3><a id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>冒泡排序</h3>
<p>时间复杂度：n^2<br />
空间复杂度：1<br />
稳定</p>
<pre><code class="language-python">def bubble_sort(elements):
    for i in range(len(elements)-1):
        flag = False
        for j in range(len(elements)-1, i, -1):
            if elements[j] &lt; elements[j-1]:
                flag = True
                elements[j], elements[j-1] = elements[j-1], elements[j]
        if not flag: break # 扫描一趟，没有发生交换，代表已经有序
    return elements
</code></pre>
<h3><a id="%E5%BF%AB%E6%8E%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快排</h3>
<p>时间复杂度：nlog2n<br />
空间复杂度：log2n<br />
不稳定</p>
<pre><code class="language-python">def quick_sort(nums):
    def partition(start, end):
        idx = random.randint(start, end) # 随机选一个，交换到头部
        nums[start], nums[idx] = nums[idx], nums[start]

        slow = fast = start + 1  # 快慢指针, 慢指针记录当前交换到哪一个位置, 快指针遍历数组找到小于标兵的数, 然后交换
        while fast &lt;= end:
            if nums[fast] &lt;= nums[start]:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
            fast += 1
        nums[start], nums[slow - 1] = nums[slow - 1], nums[start] # 把标兵放到分界点
        return slow - 1

    def helper(start, end):
        if start &lt; end:
            p = partition(start, end)
            helper(start, p-1)
            helper(p+1, end)

    helper(0, len(nums)-1)
    return nums
</code></pre>
<h2><a id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>选择排序</h2>
<h3><a id="%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简单选择排序</h3>
<p>时间复杂度：n^2<br />
空间复杂度：1<br />
不稳定</p>
<pre><code class="language-py">def select_sort(nums):
    n = len(nums)
    for i in range(n - 1): # 共进行 n-1 躺选择
        min = i
        for j in range(i+1, n):
            if nums[j] &lt; nums[min]: min = j
        nums[i], nums[min] = nums[min], nums[i]
    return nums
</code></pre>
<h3><a id="%E5%A0%86%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>堆排序</h3>
<p>时间复杂度：nlog2n<br />
空间复杂度：1<br />
不稳定<br />
<a href="16215209148366.html">优先队列</a></p>
<pre><code class="language-py">def heap_sort(nums):
    n = len(nums)
    nums.append(0)  # 添加一个元素，交换到第一个位置，作为占位，从 1 开始排序
    nums[0], nums[n] = nums[n], nums[0]

    def build_max_heap():
        for i in range(n // 2, 0, -1):
            adjust_heap(i, n)

    def adjust_heap(k, l):  # 调整以 k 为根的堆
        i = 2 * k
        while i &lt;= l:
            if i &lt; l and nums[i] &lt; nums[i + 1]: i += 1
            if nums[k] &gt;= nums[i]:
                break
            else:
                nums[i], nums[k] = nums[k], nums[i]
                k = i
            i *= 2

    build_max_heap()  # 构建堆
    for i in range(n, 1, -1):  # n-1 趟，堆顶堆尾交换，重新调整堆顶
        nums[i], nums[1] = nums[1], nums[i]
        adjust_heap(1, i - 1)

    return nums[1:]
</code></pre>
<h2><a id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>归并排序</h2>
<p>时间复杂度：nlog2n<br />
空间复杂度：n<br />
稳定</p>
<pre><code class="language-py">def merge_sort(nums):
    def merge(start, mid, end):
        tmp = nums.copy()  # 因为需要原地排序，需要拷贝一份
        p1, p2 = start, mid + 1
        p = start
        while p1 &lt;= mid and p2 &lt;= end:
            if tmp[p1] &gt; tmp[p2]:
                nums[p] = tmp[p2]
                p2 += 1
            else:
                nums[p] = tmp[p1]
                p1 += 1
            p += 1
        while p1 &lt;= mid:
            nums[p] = tmp[p1]
            p += 1
            p1 += 1
        while p2 &lt;= end:
            nums[p] = tmp[p2]
            p += 1
            p2 += 1

    def helper(start, end):
        if start &lt; end:
            mid = start + (end - start) // 2
            helper(start, mid)
            helper(mid + 1, end)
            merge(start, mid, end)
    helper(0, len(nums)-1)
    return nums
</code></pre>
<h2><a id="%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基数排序</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16215209148366.html">优先队列</a></h1>
			<p class="meta"><time datetime="2021-05-20T22:28:34+08:00" 
			pubdate data-updated="true">2021/05/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%B0%8F%E9%A1%B6%E5%A0%86">小顶堆</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
</ul>
</div>
<h2><a id="%E5%B0%8F%E9%A1%B6%E5%A0%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小顶堆</h2>
<p>python 中内置了小顶堆，如果想实现大顶堆，操作的时候取反<br />
heapq 同样支持自定义的数据类型，需要给自定义的数据类型定义 <code>__cmp__</code> 函数</p>
<pre><code class="language-python">from heapq import *

heap = []
heappush(heap, 1) # 像堆中插入元素
heappush(heap, 3)
heappush(heap, 2)
heappush(heap, 9)
heappop(heap)     # 弹出最小的元素
print(heap)
heap = [1,2,4,2,1] 
heapify(heap)      # 将list转成堆
print(heap)
</code></pre>
<p><a href="https://mp.weixin.qq.com/s/o7tdyLiYm668dpUWd-x7Lg">优先队列的实现</a></p>
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<pre><code class="language-python">class Heap:
    def __init__(self):
        self.heap = []

    def inset(self, x):
        self.heap.append(x)
        self.swim(len(self.heap)-1)

    def delete_max(self):
        tmp = self.heap[0]
        self.exchange(0, len(self.heap)-1)
        self.heap.pop()
        self.sink(0)
        return tmp

    def swim(self, k):
        while k &gt; 0 and self.heap[k] &lt; self.heap[self.parent(k)]:
            self.exchange(k, self.parent(k))
            k = self.parent(k)

    def sink(self, k):
        while self.left(k) &lt; len(self.heap):
            tmp = self.left(k)
            if self.right(k) &lt; len(self.heap) and self.heap[self.right(k)] &lt; self.heap[tmp]:
                tmp = self.right(k)
            if self.heap[k] &lt; self.heap[tmp]: break
            self.exchange(k, tmp)
            k = tmp

    def exchange(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

    def parent(self, i):
        return (i - 1) // 2

    def left(self, i):
        return 2 * i + 1

    def right(self, i):
        return 2 * (i + 1)
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16201483523405.html">并查集 Union-Find</a></h1>
			<p class="meta"><time datetime="2021-05-05T01:12:32+08:00" 
			pubdate data-updated="true">2021/05/05</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="https://labuladong.gitee.io/algo/2/19/33/">UNION-FIND算法详解</a></p>
<pre><code class="language-python">class UF:
    def __init__(self, lenght):
        self.count = lenght
        self.parent = [-1]*lenght
        self.size = [1]*lenght # 记录以每个节点为根节点的负载
        for i in range(lenght):
            self.parent[i] = i
    
    def conected(self, a, b):
        return self.find_parent(a) == self.find_parent(b)

    def union(self, a, b):
        a_p = self.find_parent(a)
        b_p = self.find_parent(b)
        if self.size[a_p] &gt; self.size[b_p]: # 负载平衡
            self.parent[b_p] = a_p
            self.size[a_p] += self.size[b_p]
        else:
            self.parent[a_p] = b_p
            self.size[b_p] += self.size[a_p]
        self.count -= 1

    def find_parent(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]] # 压缩
            x = self.parent[x]
        return x
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16197852235052.html">二分查找</a></h1>
			<p class="meta"><time datetime="2021-04-30T20:20:23+08:00" 
			pubdate data-updated="true">2021/04/30</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题</h2>
<p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">https://leetcode-cn.com/problems/koko-eating-bananas/</a></p>
<h2><a id="code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>code</h2>
<pre><code class="language-python">class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:
        max_speed = max(piles)
        piles_len = len(piles)
        def can_eat(speed):
            tmp = map(lambda x: math.ceil(x/speed), piles)
            if sum(tmp) &lt;= h: return True
            else: return False
        
        up, low = max_speed, 1
        while up &gt; low:
            m = (low + up) // 2 
            if can_eat(m):
                up = m
            else: 
                low = m+1
            
        return low
</code></pre>
<h2><a id="%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Amid%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4%E8%BF%98%E6%98%AF%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何确定 mid 向下取整还是向上取整</h2>
<p>主要考虑开闭区间，参考 <a href="https://labuladong.gitee.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/">https://labuladong.gitee.io/algo/算法思维系列/二分查找详解/</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16191881416396.html">Python 基础</a></h1>
			<p class="meta"><time datetime="2021-04-23T22:29:01+08:00" 
			pubdate data-updated="true">2021/04/23</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5">牛客输入</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC">最大最小值</a></li>
<li><a href="#list">list</a></li>
<li><a href="#set">set</a></li>
<li><a href="#math">math</a></li>
<li><a href="#str">str</a></li>
<li><a href="#random">random</a></li>
</ul>
</div>
<h2><a id="%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>牛客输入</h2>
<pre><code class="language-python">import sys 
for line in sys.stdin:
    a = line.split()
    print(int(a[0]) + int(a[1]))
</code></pre>
<h2><a id="%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最大最小值</h2>
<pre><code class="language-python">float('-inf') # min
float('inf') # max
sys.maxsize # int max
</code></pre>
<h2><a id="list" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>list</h2>
<ol>
<li>
<p>切片是左闭右开 <code>[start, end)</code></p>
</li>
<li>
<p>切片是浅拷贝，可能会浪费空间</p>
</li>
<li>
<p>使用 <code>index(a, start, end)</code> 查找元素时，如果制定了起止范围 (左闭右开)，返回的索引仍然是全局的索引，而不是在起止范围内的索引</p>
</li>
<li>
<p>多维排序，<code>list.sort(key=lambda x: (x[0], -x[1]))</code> 代表先使用第一维排序，第一维相等的利用第二维倒序排序</p>
</li>
<li>
<p><code>sum(a, [])</code> 可以将多维 list 转成一维, 原理是:</p>
<pre><code class="language-python">sum(a) # 计算结果是sum(a) = 0 + 1 + 2 + 3， 起始start默认为0，是整数，加法没问题
</code></pre>
<p>如果是二维list，如[[1,2,3],[4,5,6]], 这时迭代器每个元素均为list，这些元素作加法时start不能再使用默认整数类型值0了，因为整数和list无法做加法运算,即1+[1,2,3]+[4,5,6]运算是错误的，此时需要设置起始变量也为list类型，如start=[],如下：</p>
<pre><code class="language-python">sum(a, start=[]) # 正确, sum(a, []) = [] + [1,2,3] + [4,5,6] = [1,2,3,4,5,6] ,这样才对
</code></pre>
</li>
</ol>
<h2><a id="set" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>set</h2>
<pre><code class="language-python">set.update(list) # 将 list 批量添加到 set
</code></pre>
<h2><a id="math" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>math</h2>
<ol>
<li>
<p>精准除法，返回浮点 <code>a/b</code></p>
</li>
<li>
<p>向下取整 <code>a//b</code> 或 <code>math.floor(a/b)</code></p>
</li>
<li>
<p>向上取整 <code>math.ceil(a/b)</code> 或 <code>(a-1)/b + 1</code></p>
</li>
<li>
<p>四舍五入 <code>round(a/b)</code></p>
<blockquote>
<p>python3.5 中，如果距离两边一样远，会保留到偶数的一边。比如<code>round(0.5)</code>和round(-0.5)都会保留到0，而<code>round(1.5)</code>会保留到2。</p>
</blockquote>
</li>
</ol>
<h2><a id="str" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>str</h2>
<ol>
<li>python 中没有字符之间的直接相减运算，但可以通过 <code>ord()</code> 函数实现 <code>ord()</code> 函数主要用来返回对应字符的 ascii 码</li>
<li><code>chr()</code> 实现 ascii 转 chr</li>
</ol>
<h2><a id="random" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>random</h2>
<pre><code class="language-python">import random

random.randint(start, end)
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16190964524317.html">二叉树</a></h1>
			<p class="meta"><time datetime="2021-04-22T21:00:52+08:00" 
			pubdate data-updated="true">2021/04/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
<li><a href="#%E9%9D%9E%E9%80%92%E5%BD%92">非递归</a>
<ul>
<li><a href="#%E5%89%8D%E5%BA%8F">前序</a></li>
<li><a href="#%E4%B8%AD%E5%BA%8F">中序</a></li>
<li><a href="#%E5%90%8E%E5%BA%8F">后序</a></li>
</ul>
</li>
</ul>
</div>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归</h2>
<pre><code class="language-python">class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        l = []
        def pre(root):
            if root == None:
                return
            # 前、中、后只需调整下面的顺序
            l.append(root.val）
            pre(root.left)
            pre(root.right)
        
        pre(root)
        return l
</code></pre>
<h2><a id="%E9%9D%9E%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>非递归</h2>
<h3><a id="%E5%89%8D%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前序</h3>
<pre><code class="language-python">class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        stack = []
        l = []
        p = root
        while stack or p: # 注意 p != None
            while p:
                stack.append(p)
                l.append(p.val) # 和中序仅仅这一行位置不同
                p = p.left 
            p = stack.pop()
            p = p.right
        return l
</code></pre>
<h3><a id="%E4%B8%AD%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中序</h3>
<pre><code class="language-python">class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        stack = []
        l = []
        p = root
        while stack or p : # 注意 p != None
            while p: # stack 的作用是保存遍历过的节点，原路返回时能找到右子树
                stack.append(p)
                p = p.left 
            p = stack.pop()
            l.append(p.val)
            p = p.right
        return l
</code></pre>
<h3><a id="%E5%90%8E%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后序</h3>
<pre><code class="language-python">class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        stack = []
        l = []
        p = root
        lastVisit = None
        while stack or p:
            while p:
                stack.append(p)
                p = p.left
            node = stack[-1] # 这里只看不 pop
            if node.right == None or node.right == lastVisit: # 如果这个节点没有右子树或者右子树刚刚访问过，就访问这个节点
                result = stack.pop()
                l.append(result.val)
                lastVisit = result # 标记当前 pop 出来的节点
            else:
                p = node.right
        
        return l
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16190960540396.html">栈 & 队列</a></h1>
			<p class="meta"><time datetime="2021-04-22T20:54:14+08:00" 
			pubdate data-updated="true">2021/04/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#deque">deque</a></li>
</ul>
</div>
<h2><a id="deque" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>deque</h2>
<pre><code class="language-python">s = deque()
q = deque()

s.append(1) # 入栈
q.append(1) # 入队列

s.pop() # 出栈
q.popleft() # 出队列

len(q) # 统计个数
q.clear() # 清空
if q: # 判断是否为空
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16190805100771.html">KMP</a></h1>
			<p class="meta"><time datetime="2021-04-22T16:35:10+08:00" 
			pubdate data-updated="true">2021/04/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%88%A9%E7%94%A8next%E8%A1%A8%E5%8C%B9%E9%85%8D">利用 next 表匹配</a></li>
<li><a href="#%E6%9E%84%E5%BB%BAnext%E8%A1%A8">构建 next 表</a></li>
<li><a href="#code">code</a></li>
<li><a href="#ref">ref</a></li>
</ul>
</div>
<blockquote>
<p>有一个字符串&quot;BBC ABCDAB ABCDABCDABDE&quot;，我想知道，里面是否包含另一个字符串&quot;ABCDABD&quot;？</p>
</blockquote>
<h2><a id="%E5%88%A9%E7%94%A8next%E8%A1%A8%E5%8C%B9%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>利用 next 表匹配</h2>
<ol>
<li>
<p>首先，字符串&quot;BBC ABCDAB ABCDABCDABDE&quot;的第一个字符与搜索词&quot;ABCDABD&quot;的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。<br />
<img src="media/16190805100771/16190805443698.png" alt="" style="width:442px;" /></p>
</li>
<li>
<p>因为B与A不匹配，搜索词再往后移。<br />
<img src="media/16190805100771/16190805526871.png" alt="" style="width:453px;" /></p>
</li>
<li>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。<br />
<img src="media/16190805100771/16190805661187.png" alt="" style="width:432px;" /></p>
</li>
<li>
<p>接着比较字符串和搜索词的下一个字符，还是相同。<br />
<img src="media/16190805100771/16190805790433.png" alt="" style="width:438px;" /></p>
</li>
<li>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止。<br />
<img src="media/16190805100771/16190805873795.png" alt="" style="width:432px;" /></p>
</li>
<li>
<p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把&quot;搜索位置&quot;移到已经比较过的位置，重比一遍。<br />
<img src="media/16190805100771/16190805942034.png" alt="" style="width:441px;" /></p>
</li>
<li>
<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是&quot;ABCDAB&quot;。KMP算法的想法是，设法利用这个已知信息，不要把&quot;搜索位置&quot;移回已经比较过的位置，继续把它向后移，这样就提高了效率。<br />
<img src="media/16190805100771/16190806030270.png" alt="" style="width:432px;" /></p>
</li>
<li>
<p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。<br />
<img src="media/16190805100771/16190806131922.png" alt="" style="width:483px;" /></p>
</li>
<li>
<p>已知空格与D不匹配时，前面六个字符&quot;ABCDAB&quot;是匹配的。查表可知，最后一个匹配字符B对应的&quot;部分匹配值&quot;为2，因此按照下面的公式算出向后移动的位数：</p>
</li>
</ol>
<pre><code class="language-plain_text">移动位数 = 已匹配的字符数 - 对应的部分匹配值
</code></pre>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。<br />
<img src="media/16190805100771/16190806209113.png" alt="" style="width:432px;" /></p>
<ol start="10">
<li>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（&quot;AB&quot;），对应的&quot;部分匹配值&quot;为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。<br />
<img src="media/16190805100771/16190806624602.png" alt="" style="width:435px;" /></p>
</li>
<li>
<p>因为空格与A不匹配，继续后移一位。<br />
<img src="media/16190805100771/16190806697281.png" alt="" style="width:426px;" /></p>
</li>
<li>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。<br />
<img src="media/16190805100771/16190806779279.png" alt="" style="width:442px;" /></p>
</li>
<li>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。<br />
<img src="media/16190805100771/16190806988634.png" alt="" style="width:432px;" /></p>
</li>
</ol>
<h2><a id="%E6%9E%84%E5%BB%BAnext%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构建 next 表</h2>
<p><img src="media/16190805100771/16190809682187.png" alt="" style="width:1351px;" /><br />
<img src="media/16190805100771/16190809758964.png" alt="" style="width:1356px;" /><br />
如果 p[j] != p[i]，我们就要在 i-1 的已匹配的后缀从前面开始缩小位数，将后缀从前面开始缩小等于将匹配的前缀从后面开始缩小，等价于找 π(π(i−1)−1)，所以 j = next[j - 1]</p>
<p><img src="media/16190805100771/16190809806861.png" alt="" style="width:1350px;" /><br />
<img src="media/16190805100771/16190809876074.png" alt="" style="width:1292px;" /></p>
<h2><a id="code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>code</h2>
<pre><code class="language-python">class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        if needle == &quot;&quot;:
            return 0

        h_len, n_len = len(haystack), len(needle)

        def cal_next():
            next = [0]*n_len
            j, i = 0, 1
            while i &lt; n_len:
                if needle[i] == needle[j]:
                    next[i] = j + 1
                    i += 1
                    j += 1
                elif j:
                    j = next[j - 1]
                else:
                    next[i] = 0
                    i += 1
            return next

        next = cal_next()
        h_i, n_i = 0, 0
        flag = -1
        while h_i &lt; h_len:
            if haystack[h_i] == needle[n_i]:
                h_i += 1
                n_i += 1
            elif n_i:
                n_i = next[n_i-1]
            else:
                h_i += 1
            if n_i == n_len:
                flag = h_i - n_i
                break

        return flag
</code></pre>
<h2><a id="ref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ref</h2>
<p>[1] <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法</a><br />
[2] <a href="https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">【宫水三叶】简单题学 KMP 算法</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16248800865693.html">类加载</a></h1>
			<p class="meta"><time datetime="2021-06-28T19:34:46+08:00" 
			pubdate data-updated="true">2021/06/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类加载器</a></li>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%89">类加载机制（对象创建过程）</a>
<ul>
<li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">双亲委派机制</a></li>
</ul>
</li>
<li><a href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">沙箱安全机制</a></li>
</ul>
</div>
<h2><a id="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类加载器</h2>
<p>作用: 加载 Class 文件 (<code>new Student();</code>), 从jvm角度来看只存在两种类加载器:</p>
<ul>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）</li>
<li>其他类加载器：由Java语言实现，继承自抽象类 <code>ClassLoader</code>
<ul>
<li>扩展类加载器（<code>Extension ClassLoader</code>）: 负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code> 或 <code>java.ext.dirs</code> 系统变量指定的路径中的所有类库</li>
<li>应用程序类加载器（<code>Application ClassLoader</code>）: 负责加载用户类路径上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Car car = new Car();
Class c = car.getClass();
System.out.println(c); // class cn.jvm.Car
ClassLoader cl = c.getClassLoader();
System.out.println(cl); // AppClassLoader
System.out.println(cl.getParent()); // ExtClassLoader
System.out.println(cl.getParent().getParent()); // null, BootClassLoader 调用的是 C++ 代码, java 获取不到
</code></pre>
<p><img src="media/16225545153969/16225606494777.jpg" alt="" class="mw_img_center" style="width:491px;display: block; clear:both; margin: 0 auto;" /></p>
<h2><a id="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类加载机制（对象创建过程）</h2>
<ul>
<li>加载 ( Loading ): 将类的 <code>.class</code> 文件生成 Class 对象</li>
<li>链接 ( Linking ):
<ul>
<li>验证 ( Verify ): 保证这个被加载的class类的正确性</li>
<li>准备 ( Prepare ): 为类中的静态字段分配内存，并设置默认的初始值</li>
<li>解析 ( Resolve ): 将常量池内的符号引用转换为直接引用的过程</li>
</ul>
</li>
<li>初始化 ( initialization ): 执行类的构造器方法 <code>init()</code></li>
</ul>
<h3><a id="%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双亲委派机制</h3>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此 (<code>BOOT &lt;-- EXT &lt;-- APP</code>)，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类报出 <code>ClassNotFound</code>）时，子加载器才会尝试去加载类. 防止系统类库被恶意替换成用户自定义的类.</p>
<p>例如: 程序员写了一个 <code>java.lang.String</code> 类, 执行加载类的时候, BOOT 加载器会发现 <code>rt.jar</code> 里有 <code>java.lang.String</code> 类, 这时最终加载的类就是 <code>rt.jar</code> 里面的类.</p>
<pre><code class="language-java">package java.lang;
    
public class String {
    public String toString() {
        return &quot;hello, my String !&quot;;
    }
    
    public static void main(String[] args) {
        String s = new String();
        s.toString();
    }
}
// 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
// public static void main(String[] args)
// 否则 JavaFX 应用程序类必须扩展javafx.application.Application
</code></pre>
<p>为了完成某些操作，可以 “破坏” 模型。</p>
<ol>
<li>重写 <code>ClassLoader</code> 类的 <code>loadClass</code> 方法</li>
<li>利用线程上下文加载器（Thread Context ClassLoader）。这个类加载器可以通过 <code>java.lang.Thread</code> 类的 <code>setContextClassLoaser()</code> 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
<li>为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。</li>
</ol>
<h2><a id="%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>沙箱安全机制</h2>
<p>沙箱安全机制: 将 Java 代码限定在虚拟机 JVM 特定的范围中，严格限制代码对本地资源的访问。</p>
<p>由以下部分组成</p>
<ul>
<li>字节码校验器: 确保 Java 类文件遵循 Java 语言规范</li>
<li>类装载器: 防止恶意代码干涉善意代码(双亲委派) / 守护被信任的类库边界 / 确定代码可以进行哪些操作(沙箱)</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16248798475118.html">GC</a></h1>
			<p class="meta"><time datetime="2021-06-28T19:30:47+08:00" 
			pubdate data-updated="true">2021/06/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#gc%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">GC 触发条件</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%B4%BB%E7%9D%80">判断对象是否活着</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">引用计数法</a></li>
<li><a href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90">可达性分析</a>
<ul>
<li><a href="#%E4%B8%89%E8%89%B2%E6%B3%95">三色法</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8">四种引用</a></li>
</ul>
</li>
<li><a href="#gc%E7%AE%97%E6%B3%95">GC 算法</a>
<ul>
<li><a href="#%E6%AF%94%E8%BE%83">比较</a></li>
<li><a href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6">分代回收</a></li>
</ul>
</li>
<li><a href="#8%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">8 种垃圾收集器</a>
<ul>
<li><a href="#serial">Serial</a></li>
<li><a href="#parnew">ParNew</a></li>
<li><a href="#parallel-scavenge-parallel-old">Parallel ScaVenge &amp; Parallel Old</a></li>
<li><a href="#cms">CMS</a></li>
<li><a href="#g1">G1</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98">如何调优</a></li>
</ul>
</div>
<p>GC 的作用区域是堆和方法区 ( 规范中不对方法区做要求, 但 HotSpot 为方法区实现了 GC ), 大部分都是在新生代。分为轻 GC (普通 GC), 重 GC (全局 GC)</p>
<h2><a id="gc%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GC 触发条件</h2>
<ul>
<li>Minor GC：当 Eden 空间满时，就将触发一次 Minor GC</li>
<li>Full GC：
<ul>
<li>
<p>当调用 <code>System.gc()</code> 建议虚拟机执行 FG，不建议使用</p>
</li>
<li>
<p>老年代空间不足，（可以调大新生代空间或调大进入老年代的年龄尽量避免发生 FG）</p>
</li>
<li>
<p>空间分配担保失败</p>
<blockquote>
<p>Minor GC 之前，先检查老年代的最大可用连续空间是否大于新生代所有对象空间，如果是，Minor GC 可以进行；如果不是，再检查 JVM 是否允许担保失败，如果允许再检查老年代的最大可用连续空间是否大于历代晋升到老年代对象的平均大小，如果大于，尝试进行 Minor GC，如果小于或不允许担保失败，就进行一次 Full GC</p>
</blockquote>
</li>
<li>
<p>JDK 1.7 之前永久代空间不足，且没有采用 CMS GC 时也会执行 Full GC。</p>
</li>
</ul>
</li>
</ul>
<h2><a id="%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%B4%BB%E7%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断对象是否活着</h2>
<h3><a id="%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用计数法</h3>
<p>为每个对象维护一个计数器, 保存当前被引用次数，为 0 的对象被清除</p>
<ul>
<li>优点: 实现简单, 效率高</li>
<li>缺点: 很难解决对象之间循环引用的问题</li>
</ul>
<h3><a id="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可达性分析</h3>
<p>和 GC Roots 对象 ( 栈帧中的本地变量中引用的对象 / 方法区中类静态属性引用的对象 / 方法区中常量引用的对象 / 本地方法栈中引用的对象 ) 直接或间接关联的对象是有效对象，反之则是无效对象。</p>
<h4><a id="%E4%B8%89%E8%89%B2%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三色法</h4>
<p>可达性分析时，把遍历对象图过程中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li>白色：尚未访问过。</li>
<li>黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问过了。</li>
<li>灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问完。全部访问后，会转换为黑色。</li>
</ul>
<p><strong>过程</strong>：</p>
<ol>
<li>初始时，所有对象都在【白色集合】中；</li>
<li>将 GC Roots 直接引用到的对象挪到 【灰色集合】中；</li>
<li>从灰色集合中获取对象：
<ul>
<li>将本对象引用到的其他对象全部挪到【灰色集合】中；</li>
<li>将本对象挪到【黑色集合】里面。</li>
</ul>
</li>
</ol>
<p><strong>问题</strong>：假设 A -&gt; B -&gt; C，一开始 A 在灰色，然后扫描 A，将 B 添加到灰色，将 A 添加到黑色；此时 A 新增引用 C，B 断开对 C 的引用。因为 A 已经在黑色中，不会再扫描，而 B 也没有了对 C 的引用，那么 C 会被当作垃圾回收，A -&gt; C 就出现了漏标。<br />
解决：黑色对象引用白色对象或删除灰色对象对白色对象的引用时时，都将白色对象置为灰色；</p>
<h3><a id="%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四种引用</h3>
<ul>
<li>强引用: 绝大多数都是强引用, 垃圾回收器不会回收它</li>
<li>软引用: 类似于可有可无的引用，当内存不足时，就会回收。</li>
<li>弱引用: 也是可有可无的引用，比软引用具有更短暂的生命周期，在GC扫描时，无论内存是否够用，都会回收</li>
<li>虚引用: 和没有引用一样，任何时候都有可能被回收</li>
</ul>
<h2><a id="gc%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GC 算法</h2>
<ul>
<li>标记-清除: 第一次遍历 GC Roots 对象, 将 GC Roots 对象可达到的堆内存对象进行标记, 第二次遍历堆内存对象, 将没有标记的对象清除
<ul>
<li>优点: 不需要额外的空间</li>
<li>缺点: 两次扫描效率不高, 产生内存碎片无法生成大对象造成频繁 GC</li>
</ul>
</li>
<li>标记-复制: 进行可达性分析的时候, 凡是能达到的对象都复制到 to 区, 再一次性清除伊甸园区和 from 区
<ul>
<li>优点: 没有内存碎片, 因为每次清理, 都会把活下来的对象<strong>连续地</strong>复制到 to  区中</li>
<li>缺点: 浪费内存空间, 复制的对象比较多时, 效率慢, 适合对象存活率低的情况</li>
</ul>
</li>
<li>标记-压缩: 标记完成以后, 让所有存活对象向一端移动, 然后直接清理掉一端边界外的内存
<ul>
<li>优点: 内存规整</li>
<li>缺点: 效率不如复制算法</li>
</ul>
</li>
</ul>
<h3><a id="%E6%AF%94%E8%BE%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>比较</h3>
<p>效率: 标记复制 &gt; 标记压缩 &gt; 标记清除 ( 引发更多 GC )<br />
内存规整率: 标记压缩 = 标记复制 &gt; 标记清除<br />
内存利用率: 标记压缩 = 标记清除 &gt; 标记复制</p>
<h3><a id="%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分代回收</h3>
<p>结合以上几种算法: 把 Java 堆分为新生代和老年代，根据各个对象的年代采用最合适的收集算法。针对新生代的对象，采取灵活比例的复制算法，只需要复制少量存活对象就可以完成收集。针对老年代的对象，因为这些对象存活率高，没有额外空间进行分配担保，必须使用标记清除或标记压缩算法。</p>
<h2><a id="8%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8 种垃圾收集器</h2>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#minor-gc-%E5%92%8C-full-gc">参考</a></p>
<p><img src="media/16248720428830/16248720638327.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<h3><a id="serial" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Serial</h3>
<p>进行垃圾收集工作的时候必须暂停其他所有的工作线程，单线程串行执行，简单高效<br />
新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理</strong>算法。</p>
<h3><a id="parnew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ParNew</h3>
<p>Serial 的多线程版本，性能高，Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作<br />
新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理</strong>算法。</p>
<h3><a id="parallel-scavenge-parallel-old" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parallel ScaVenge &amp; Parallel Old</h3>
<p>多线程，其他收集器是尽量缩短垃圾收集的停顿时间，适合交互程序，而它的目标是吞吐量优先，尽可能高的利用 CPU，适合后台任务。<br />
可以通过参数打开自适应调节，能根据系统运行情况动态调整参数以提供最适合的停顿时间或吞吐量。<br />
Parallel ScaVenge 采用<strong>复制算法</strong>，Parallel Old 采用<strong>标记-整理</strong>算法。</p>
<h3><a id="cms" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMS</h3>
<p>Concurrent Mark Sweep，采用<strong>标记-清除</strong>算法，真正意义上的并发收集器。分四个阶段：</p>
<ul>
<li>初始标记：暂停所有线程，记录直接与 root 相连的对象，时间很短</li>
<li>并发标记：GC 和 用户线程同时开启，并跟踪用户线程发生引用更新的地方</li>
<li>重新标记：暂停用户进程，根据第二步引用变更的地方，并发重新标记，时间很短</li>
<li>并发清除：开启用户线程，同时 GC 线程开始清理工作</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p><img src="media/16248720428830/16248783456729.jpg" alt="" class="mw_img_center" style="width:705px;display: block; clear:both; margin: 0 auto;" /></p>
<h3><a id="g1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>G1</h3>
<p>面向服务端应用，在多 CPU 和大内存的场景下有很好的性能。可以直接对新生代和老年代一起回收。（标记整理，可预测停顿）<br />
G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离，使得每个小空间可以单独进行垃圾回收。通过记录每个 Region 垃圾回收时间以及回收所获得的空间，维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。<br />
<img src="media/16248720428830/16248792437880.jpg" alt="" class="mw_img_center" style="width:489px;display: block; clear:both; margin: 0 auto;" /></p>
<p>回收过程和 CMS 类似，但最后一步是筛选回收，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何调优</h2>
<p>现在都是分代回收，尽量让对象在新生代就回收，减少大对象的分配。需要平衡分代大小、垃圾回收次数和停顿时间。<br />
对 GC 进行完整的监控，监控各年代占用大小、YGC、FGC 触发频率，对象分配速率等，然后根据实际情况调优。<br />
比如 FGC 频率高，可能是第三方库调用了 System.gc，或者 CMS 触发阈值过低等；还有对象年龄晋升阈值、幸存区大小等。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16248673414388.html">OOM</a></h1>
			<p class="meta"><time datetime="2021-06-28T16:02:21+08:00" 
			pubdate data-updated="true">2021/06/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E6%BA%A2%E5%87%BA%EF%BC%88java-lang-outofmemoryerror%EF%BC%9Ajava-heap-space%EF%BC%89">堆空间溢出（<code>java.lang.OutOfMemoryError：java heap space</code>）</a></li>
<li><a href="#%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%BA%A2%E5%87%BA%EF%BC%88java-lang-outofmemoryerror%EF%BC%9Apermgen-space%EF%BC%89">永久代溢出（<code>java.lang.OutOfMemoryError：PermGen space</code>）</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88outofmemoryerror-direct-buffer-memory%EF%BC%89">直接内存溢出（<code>OutOfMemoryError: Direct buffer memory</code>）</a></li>
<li><a href="#jprofiler">Jprofiler</a></li>
</ul>
</div>
<h2><a id="%E5%A0%86%E7%A9%BA%E9%97%B4%E6%BA%A2%E5%87%BA%EF%BC%88java-lang-outofmemoryerror%EF%BC%9Ajava-heap-space%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>堆空间溢出（<code>java.lang.OutOfMemoryError：java heap space</code>）</h2>
<p>老年代区域剩余的内存，已经无法满足将要晋升到老年代区域的对象大小，会报此错。</p>
<p>原因：</p>
<ul>
<li>设置的堆内存太小；</li>
<li>内存泄露如 File 资源没有回收；</li>
<li>请求创建超大对象或数组；</li>
<li>设计问题如使用过多的缓存</li>
</ul>
<p>解决：</p>
<ul>
<li>调高 <code>-Xmx</code> 参数增大堆内存</li>
<li>如果是内存泄漏，检查持有的对象，修改代码</li>
<li>如果是超大对象，检查它的合理性，比如一次性查询了数据库全部结果</li>
<li>业务峰值压力可以考虑增加机器资源，或者限流</li>
</ul>
<h2><a id="%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%BA%A2%E5%87%BA%EF%BC%88java-lang-outofmemoryerror%EF%BC%9Apermgen-space%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>永久代溢出（<code>java.lang.OutOfMemoryError：PermGen space</code>）</h2>
<p>该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。</p>
<p>解决：</p>
<ul>
<li>如果程序启动时报错，修改 <code>-XX:MaxPermSize</code> 或 <code>-XX:MaxMetaspaceSize</code> 调大永久区</li>
<li>应用重新部署时报错，可能是应用根本没有重启，导致加载了过多的 class，重启 JVM</li>
<li>运行时报错，可能是动态创建了大量 class，可以通过设置 <code>-XX:+CMSClassUnloadingEnabled</code> 和 <code>-XX:+UseConcMarkSweepGC</code> 这两个参数允许 JVM 卸载 class。</li>
</ul>
<h2><a id="%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88outofmemoryerror-direct-buffer-memory%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接内存溢出（<code>OutOfMemoryError: Direct buffer memory</code>）</h2>
<p>Java 允许应用程序直接访问堆外内存，通过直接内存结合内存映射文件实现高速 IO。直接内存最大是 64 MB，一旦使用超出限制，就会抛出 Directbuffer memory 错误。</p>
<p>解决：</p>
<ul>
<li>通过<code>-XX:MaxDirectMemorySize</code> 调整 Direct ByteBuffer 的上限值。</li>
<li>检查是否有 <code>-XX:+DisableExplicitGC</code> 参数，如果有就去掉，因为该参数会使 <code>System.gc()</code> 失效。</li>
<li>尝试使用 Cleaner 的 <code>clean()</code> 方法主动释放直接内存空间。</li>
</ul>
<h2><a id="jprofiler" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jprofiler</h2>
<p>内存快照分析工具 ( MAT, Jprofiler ) 分析 Dump 内存文件 ( 使用 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 生成, 其中 <code>OutOfMemoryError</code> 可以改成其他错误类型 ), 查看堆中的数据和大对象, 然后查看 Thread Dump 里面具体的代码位置</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227314617502.html">JMM</a></h1>
			<p class="meta"><time datetime="2021-06-03T22:44:21+08:00" 
			pubdate data-updated="true">2021/06/03</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#jmm%E6%93%8D%E4%BD%9C">JMM 操作</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BA%A6%E5%AE%9A">同步的约定</a></li>
<li><a href="#jmm%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">JMM 解决的问题</a></li>
<li><a href="#volatile%E4%BD%9C%E7%94%A8">volatile 作用</a></li>
</ul>
</div>
<blockquote>
<p>JMM (Java Memory Model)</p>
</blockquote>
<h2><a id="%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概念</h2>
<p>JMM 规范了 Java 虚拟机与计算机内存是如何协同工作的, 用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的并发效果</p>
<p>JMM 定义了线程和主内存之间抽象关系:</p>
<ul>
<li>线程之间的共享变量存储在主内存 (硬件的内存)</li>
<li>每个线程都有一个私有的本地内存, 这个本地内存是一个抽象概念, 涵盖了cpu寄存器和高速缓存等</li>
</ul>
<h2><a id="jmm%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JMM 操作</h2>
<p>JMM 定义了以下八种操作来完成主内存与工作内存之间的具体交互:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用在哪里</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock</td>
<td>主内存</td>
<td>锁定主内存变量, 让他只供一个线程使用</td>
</tr>
<tr>
<td>read</td>
<td>主内存</td>
<td>把一个变量值从主内存传输到线程的工作内存中</td>
</tr>
<tr>
<td>load</td>
<td>线程内存</td>
<td>把 read 到的变量值放入工作内存的变量副本中</td>
</tr>
<tr>
<td>use</td>
<td>线程内存</td>
<td>把工作内存中的一个变量值传递给执行引擎</td>
</tr>
<tr>
<td>assign</td>
<td>线程内存</td>
<td>把一个从执行引擎接收到的值赋值给工作内存的变量</td>
</tr>
<tr>
<td>store</td>
<td>线程内存</td>
<td>把工作内存中的一个变量的值传送到主内存中</td>
</tr>
<tr>
<td>write</td>
<td>主内存</td>
<td>把 store 操作传过来的值更新到主内存中</td>
</tr>
<tr>
<td>unlock</td>
<td>主内存</td>
<td>解锁主内存变量</td>
</tr>
</tbody>
</table>
<h2><a id="%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BA%A6%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>同步的约定</h2>
<ul>
<li>解锁前，必须把共享变量立刻刷新会主存</li>
<li>加锁前，必须读取主存中最新值到工作内存中</li>
<li>加锁解锁是同一把锁</li>
<li>read 和 load, store 和 write, lock 和 unlock 必须成对按顺序出现, 但可以不连续</li>
</ul>
<h2><a id="jmm%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JMM 解决的问题</h2>
<ul>
<li>可见性: 当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改, 可以使用 <code>volatile</code>, <code>synchronized</code>, <code>final</code> 来保证</li>
<li>原子性: 一个操作是不可分割，不可中断的, 可以使用 <code>synchronized</code> ，锁或原子类来保证</li>
<li>有序性: 使用 <code>volatile</code> 和 <code>synchronized</code> 保证多线程之间操作的有序性</li>
</ul>
<h2><a id="volatile%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>volatile 作用</h2>
<ol>
<li>
<p><strong>保证线程间变量的可见性</strong>: 读取变量时, 总是读取主存新值, 变量被修改后会立刻刷新到主内存。(可见性不能保证操作的原子性，需要保证线程安全的话，使用 <code>synchronized</code> 关键字或者 lock 锁)</p>
</li>
<li>
<p><strong>不保证原子型</strong></p>
</li>
<li>
<p><strong>禁止 CPU 进行指令重排序</strong>: 在加 <strong>volatile</strong> 的地方上下加一层<strong>内存屏障</strong> ( 禁止上面的指令和下面的指令顺序交换 )</p>
<pre><code class="language-java">// 语句 3 固定位置, 但是语句1和2的顺序是不能保证的，同理，语句4、5也不能保证顺序
a = 1;  //语句1
b = 2;  //语句2
k = 3;  // volatile 语句3
a = 4;  //语句4
b = 5;  //语句5
</code></pre>
</li>
</ol>
<p><strong>如果不加 lock 和 synchronized 怎么保证原子性？</strong><br />
使用 <code>java.util.concurrent.atomic</code> 包下的原子类，解决原子性问题。 例如 <code>AtomicInteger</code> 类的 <code>getAndIncrement()</code> 使用的是底层 CAS 的 +1 方法，直接和操作系统挂钩，直接在内存中修改值，效率极高。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16225545153969.html">JVM 内存划分</a></h1>
			<p class="meta"><time datetime="2021-06-01T21:35:15+08:00" 
			pubdate data-updated="true">2021/06/01</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#jvm%E4%BD%8D%E7%BD%AE">JVM 位置</a></li>
<li><a href="#jvm%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">JVM 的体系结构</a></li>
<li><a href="#native%E9%87%8D%E7%82%B9">Native (重点)</a></li>
<li><a href="#pc%E5%AF%84%E5%AD%98%E5%99%A8">PC 寄存器</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a></li>
<li><a href="#%E6%A0%88">栈</a></li>
<li><a href="#%E5%A0%86%E9%87%8D%E7%82%B9">堆 (重点)</a>
<ul>
<li><a href="#%E6%96%B0%E7%94%9F%E4%BB%A3">新生代</a></li>
<li><a href="#%E8%80%81%E5%B9%B4%E4%BB%A3">老年代</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">内存分配</a></li>
</ul>
</li>
<li><a href="#%E6%B0%B8%E4%B9%85%E5%8C%BA%E5%85%83%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95%E5%8C%BA">永久区 &amp; 元空间 &amp; 方法区</a></li>
</ul>
</div>
<h2><a id="jvm%E4%BD%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JVM 位置</h2>
<p>JVM本质是虚拟机, 运行在操作系统之上, 而 Java 程序运行在 JVM 之上, 运行 Java 程序只需要 JRE 就够了, JRE 包括了 Java 运行环境以及 JVM, 如果需要开发 Java 程序, 才需要安装 JDK</p>
<ul>
<li>三种 JVM
<ul>
<li>Sun 公司: HotSpot</li>
<li>BEA 公司: JRockit, 不常用, 但性能很高</li>
<li>IBM 公司: J9VM, 不常用, 资料少, 在 IBM 独占平台会用到</li>
</ul>
</li>
</ul>
<h2><a id="jvm%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JVM 的体系结构</h2>
<p>我们所说的 JVM 调优就是调<strong>方法区</strong>和<strong>堆</strong>, 其他的地方不会产生垃圾</p>
<p><img src="media/16225545153969/16225646536509.jpg" alt="" class="mw_img_center" style="width:479px;display: block; clear:both; margin: 0 auto;" /></p>
<h2><a id="native%E9%87%8D%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Native (重点)</h2>
<p>凡是带了 <code>native</code> 关键字的, 说明 Java 的作用范围达不到了, 会调用底层的库</p>
<p>过程: 在内存区域中专门开辟了一块标记的区域 (Native Method Stack), 登记了 native 方法, 等到执行的时候, 再通过 JNI 执行本地方法库中的方法</p>
<p>作用: 扩展 Java 的使用, 融合不同的编程语言为 Java 所用 (最初: C/C++)<br />
目前 Java 调用其他接口方法: Socket / WebService / http 等</p>
<h2><a id="pc%E5%AF%84%E5%AD%98%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PC 寄存器</h2>
<p>每个线程都有一个 PC, 是一个指向下一条指令的指针, 用于执行引擎执行下一条指令, 空间非常小可以忽略不计</p>
<h2><a id="%E6%96%B9%E6%B3%95%E5%8C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法区</h2>
<ul>
<li>方法区是所有线程<strong>共享</strong>的, 所有定义的方法 (字段 / 方法字节码 / 构造函数 / 接口等) 都保存在该区域</li>
<li><strong>静态变量 / 常量 / 类信息 (构造函数 接口定义) / 运行时常量池存在方法区中, 但是实例变量存在堆内存中</strong></li>
</ul>
<h2><a id="%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>栈</h2>
<ul>
<li>
<p>栈内存主要存放 8 大基本类型 / 对象引用 / 实例的方法</p>
</li>
<li>
<p><strong>栈是线程级的</strong>, 主管程序的运行, 当调用另一个方法, 就会把这个方法压入栈顶 (栈帧), 执行完毕就被弹出栈, 继续执行调用它的方法, 生命周期和线程同步, 线程结束, 栈内存也就释放<br />
<code>StackOverflowError</code>: 递归程序处理不当容易栈满</p>
</li>
</ul>
<p><img src="media/16225545153969/16225662992996.jpg" alt="" class="mw_img_center" style="width:223px;display: block; clear:both; margin: 0 auto;" /></p>
<h2><a id="%E5%A0%86%E9%87%8D%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>堆 (重点)</h2>
<ul>
<li>一个 JVM 只有一个堆内存, 内存大小是可以调节的</li>
<li>堆中存放类 / 方法 / 常量 / 变量, 保存所有引用类型的真实对象</li>
<li>堆内存分为两个区域: 新生区, 老年区</li>
</ul>
<h3><a id="%E6%96%B0%E7%94%9F%E4%BB%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新生代</h3>
<ul>
<li>一个类诞生, 成长的地方, 甚至死亡</li>
<li>分为两个区
<ul>
<li>伊甸园 <code>Eden Space</code>: 所有的对象都是在伊甸园区 New 出来的</li>
<li>幸存区(from, to 区): 轻 GC 后活下来的对象</li>
</ul>
</li>
</ul>
<h3><a id="%E8%80%81%E5%B9%B4%E4%BB%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>老年代</h3>
<p>大对象直接进入老年代，存活年龄超过阈值的对象进入老年代</p>
<h3><a id="%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分配</h3>
<ol>
<li>对象优先在 Eden 分配</li>
<li>大对象直接进入老年代</li>
<li>存活年龄超过阈值的对象进入老年代（动态年龄判断：如果幸存区相同年龄的对象超过一半，那么超过这个年龄的对象直接进入老年代）</li>
</ol>
<h2><a id="%E6%B0%B8%E4%B9%85%E5%8C%BA%E5%85%83%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95%E5%8C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>永久区 &amp; 元空间 &amp; 方法区</h2>
<p>参考: <a href="https://blog.csdn.net/u011635492/article/details/81046174">永久区 &amp; 方法区</a></p>
<p>Java 虚拟机规范只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在不同的 JVM 上方法区的实现不同。在 HotSpot 中利用永生代实现方法区。其他的虚拟机实现并没有永久带这一说法。</p>
<ul>
<li>在 1.7 之前，HotSpot 把堆中一部分区域用来实现方法区, 同时 GC 分代收集也扩展至这一区域，就称为永久代。</li>
<li>对于 Java8， HotSpots 取消了永久代. 取代永久代的就是元空间。永生代和元空间不同点为:
<ul>
<li>存储位置不同: 永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存</li>
<li>存储内容不同: 元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。</li>
</ul>
</li>
<li>一个启动类, 加载了大量的第三方 Jar 包, tomcat 部署了太多应用, 大量动态生成的反射类. 不断加载就会出现 OOM</li>
</ul>
<p><strong>为什么使用元空间替换永久代？</strong><br />
为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。<br />
当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。<br />
更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16247740620828.html">AQS</a></h1>
			<p class="meta"><time datetime="2021-06-27T14:07:42+08:00" 
			pubdate data-updated="true">2021/06/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a>
<ul>
<li><a href="#%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F">共享方式</a>
<ul>
<li><a href="#%E7%8B%AC%E5%8D%A0">独占</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB">共享</a></li>
</ul>
</li>
<li><a href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97">等待队列</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%9F">如何自定义同步器？</a></li>
</ul>
</li>
<li>[常见的同步器（<a href="16226447097561.html">辅助类</a>）](#常见的同步器（辅助类16226447097561-html）)
<ul>
<li><a href="#semaphore">Semaphore</a></li>
<li><a href="#countdownlatch">CountDownLatch</a></li>
<li><a href="#cyclicbarrier">CyclicBarrier</a></li>
</ul>
</li>
</ul>
</div>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93?id=_5-cyclicbarrier%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F">参考</a></p>
<h2><a id="%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原理</h2>
<p>AQS（<code>AbstractQueuedSynchronizer</code>）同步器，可以利用它协调线程之间的同步行为，核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列实现的，即将暂时获取不到锁的线程加入到队列中。<br />
<img src="media/16247740620828/16247741942725.jpg" alt="" class="mw_img_center" style="width:600px;display: block; clear:both; margin: 0 auto;" /></p>
<p>同步状态使用成员变量 state（ volatile、原子操作 ）表示，AQS 就是通过对 state 的原子操作来达到同步各个线程的目的。</p>
<h3><a id="%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>共享方式</h3>
<h4><a id="%E7%8B%AC%E5%8D%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>独占</h4>
<p>只有一个线程可以执行，如 ReentrantLock。又分为公平锁和非公平锁，区别有两点：</p>
<ol>
<li>非公平锁在调用 lock 后，会先使用 CAS 进行一次抢锁，抢不到就进入 <code>tryAcquire()</code> 方法；公平锁直接进入 <code>tryAcquire()</code></li>
<li>如果锁释放了，非公平锁再抢一次锁，而公平锁要判断阻塞队列有没有线程在等待，非公平锁抢不到锁或公平锁有其他线程在等待就进入阻塞队列等待唤醒</li>
</ol>
<blockquote>
<p><code>ReentrantLock</code>，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 state+1。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。</p>
</blockquote>
<h4><a id="%E5%85%B1%E4%BA%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>共享</h4>
<p>多个线程可以同时执行，如 Semaphore、CountDownLatch。</p>
<h3><a id="%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>等待队列</h3>
<p>如果获取锁失败，就加入等待队列，是如何实现的？</p>
<ol>
<li>通过当前线程和锁模式新建一个节点</li>
<li>pred 指针指向尾节点 tail</li>
<li>将新节点的 prev 指向 pred</li>
<li>通过 compareAndSetTail 完成尾节点的设置</li>
<li>如果没有初始化就构造一个空的头结点</li>
</ol>
<h3><a id="%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何自定义同步器？</h3>
<p>AQS 的设计是基于模版方法的，继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法即可（<code>tryAcquire / tryRelease</code> 或 <code>tryAcquireShared / tryReleaseShared</code>）。</p>
<pre><code class="language-java">isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
</code></pre>
<h2><a id="%E5%B8%B8%E8%A7%81%E7%9A%84%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%88%E8%BE%85%E5%8A%A9%E7%B1%BB16226447097561-html%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见的同步器（<a href="16226447097561.html">辅助类</a>）</h2>
<h3><a id="semaphore" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Semaphore</h3>
<p>可以限制访问共享资源的线程数量。</p>
<p>原理是初始化 state 为 N，每个线程执行 <code>acquire()</code>，如果 state &gt; 0，就使得 state - 1，如果 state = 0，就加入阻塞队列，并自旋判断 state 是否大于 0；线程调用 <code>release()</code> 使 state + 1，阻塞的线程会竞争这个锁。</p>
<h3><a id="countdownlatch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CountDownLatch</h3>
<p>可以使多个线程阻塞在一个地方，直到所有线程任务都执行完毕。（类似倒计时的效果，<strong>一次性的</strong>）</p>
<p>原理是初始化 state 为 N，每个线程执行 <code>countDown()</code> 方法使得 state - 1，调用 <code>await()</code> 会阻塞并自旋判断 state，如果 state = 0，就释放所有等待的线程，执行 <code>await()</code> 之后的语句。</p>
<p>典型用法：</p>
<ul>
<li>主线程（<code>await</code>）等待多个子线程执行完毕（<code>countDown</code>）；</li>
<li>主线程通知（<code>countDown</code>）所有等待的线程执行（<code>await</code>），CountDownLatch 计数器需要初始化为 1。</li>
</ul>
<h3><a id="cyclicbarrier" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CyclicBarrier</h3>
<p>基于 <code>ReentrantLock</code> 实现，和 <code>CountDownLatch</code> 类似但更强大，让一组线程全部到达同步点后，这组线程才向后执行。<br />
提供了一个高级构造函数，能传入一个 <code>Runnable</code>，所有线程到达屏障后，优先执行 <code>Runnable</code>。</p>
<p>构造时指定拦截的数量 count = N，每个线程调用 <code>await()</code> 使得 count - 1，如果 count = 0，执行构造器传入的任务，然后通知所有阻塞线程执行；如果 count &gt; 0，就自旋阻塞。</p>
<blockquote>
<p><code>CyclicBarrier</code> VS <code>CountDownLatch</code></p>
<ol>
<li><code>CyclicBarrier</code> 是多个线程在任意一个没有完成时，所有线程都等待（内部等待）；<code>CountDownLatch</code> 是一/多个线程等待其他 N 个线程完成某件事情（等待外部线程）</li>
<li><code>CyclicBarrier</code> 调用 <code>await()</code> 减一后会阻塞直到计数器为 0；<code>CountDownLatch</code> 调用 <code>countDown()</code> 减一后继续运行，其他线程调用 <code>await()</code> 阻塞直到计数器为 0</li>
<li><code>CountDownLatch</code> 是一次性的；<code>CyclicBarrier</code> 提供 reset 方法</li>
</ol>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227419427125.html">CAS</a></h1>
			<p class="meta"><time datetime="2021-06-04T01:39:02+08:00" 
			pubdate data-updated="true">2021/06/04</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">原子类源码分析</a>
<ul>
<li><a href="#compareandswapint">compareAndSwapInt</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A0">实现自加</a></li>
</ul>
</li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3aba">解决 ABA</a></li>
</ul>
</div>
<blockquote>
<p>CAS: Compare And Swap, 比较并交换, CPU 并发原语, 当内存中的值和期望值相等才设置新值</p>
</blockquote>
<p><code>java.util.concurrent.atomic</code> 包下的类是原子类，内部使用 <code>Unsafe</code> 类调用 C++ 本地方法，从而底层使用了 CAS 保证操作的原子性</p>
<h2><a id="%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原子类源码分析</h2>
<p>参考 <a href="https://juejin.cn/post/6844903558937051144">Java CAS 原理剖析</a>：</p>
<h3><a id="compareandswapint" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>compareAndSwapInt</h3>
<pre><code class="language-java">compareAndSwapInt(Object var1, long var2, int var4, int var5);
</code></pre>
<ul>
<li>var1 是当前 Unsafe 类，var2 是原子类中 value 属性的偏移量，有了这两个值，就可以从内存中取得 value 的值。</li>
<li>var4 是期望值，CAS 原理就是比较内存值和期望值是否相同来决定是否更新</li>
<li>var5 是要设置的新值</li>
<li><strong>总结</strong>：如果通过 var、var2 取出来的内存值和 var4 相同，那么将内存值更新为 var5。判断比较这个过程是原子的，底层使用 <code>cmpxchgl</code> 指令，给总线加锁，同一芯片上的其他处理器就暂时不能通过总线访问内存</li>
</ul>
<h3><a id="%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现自加</h3>
<pre><code class="language-java">public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
</code></pre>
<ul>
<li>首先从内存取出值 var5 作为期望值，然后尝试加 1 后更新内存值，更新的前提是刚刚取得 var5 (期望值) 和现在内存值相同（没有其他线程修改），这一步使用 <code>compareAndSwapInt</code>，while 循环是一个乐观锁，他会判断如果刚刚取出来的值被修改了，就再次尝试重新获取新的值加 1</li>
</ul>
<h2><a id="%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缺点</h2>
<ul>
<li>开销大：在并发量比较高的情况下，如果许多线程反复竞争，尝试更新某一个变量，却又一直更新不成功，会给CPU带来很大的压力。</li>
<li>只是一个变量的原子性操作</li>
<li>ABA 问题：A线程要修改变量，B线程取到了该变量修改了，然后又改回了最初值，所以A依然能够修改成功</li>
</ul>
<h2><a id="%E8%A7%A3%E5%86%B3aba" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决 ABA</h2>
<p>使用带版本号的原子引用类 <code>AtomicStampedReference</code>，它携带一个版本号，每次更新都使版本号加 1。<code>compareAndSet</code> 首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<pre><code class="language-java">// 大坑：由于存储的值是 Object，127 自动装箱成 Ineger 类，而 Ineger 缓存池范围是 -128～127，
// 超出这个范围，会重新在堆中 new 一个对象，所以哪怕值相同地址也不同，而 AtomicStampedReference
// 内部恰恰是用 `==` 比较的地址，所以这里如果超出缓存范围，下面 CAS 会失败
AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference(127, 1);

@Test
public void test4() {
    int stamp = atomicStampedReference.getStamp();
    atomicStampedReference.compareAndSet(127, 21, stamp, stamp + 1);
    // stamp = atomicStampedReference.getStamp(); // 不加这一句获取最新版本号，下面就会执行失败，最终输出 21
    atomicStampedReference.compareAndSet(21, 22, stamp, stamp + 1);
    System.out.println(atomicStampedReference.getReference());
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227416766193.html">生产者消费者</a></h1>
			<p class="meta"><time datetime="2021-06-04T01:34:36+08:00" 
			pubdate data-updated="true">2021/06/04</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#synchronized%E7%89%88%E6%9C%AC%EF%BC%88-synchronized-wait-notify%EF%BC%89">synchronized 版本（<code>synchronized</code> <code>wait</code> <code>notify</code>）</a></li>
<li><a href="#juc%E7%89%88%E6%9C%AC%EF%BC%88-lock-await-signal%EF%BC%89">JUC 版本（<code>Lock</code> <code>await</code> <code>signal</code>）</a></li>
</ul>
</div>
<h2><a id="synchronized%E7%89%88%E6%9C%AC%EF%BC%88-synchronized-wait-notify%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>synchronized 版本（<code>synchronized</code> <code>wait</code> <code>notify</code>）</h2>
<p>使用 <code>synchronized</code> 加锁, <code>wait</code> 和 <code>notify</code> 实现 (等待 业务 通知) <strong>判断等待的时候不要使用 if, 要使用 while, 防止超过两个线程时的虚假唤醒问题</strong><br />
（拿两个加法线程A、B来说，比如A先执行，执行时调用了wait方法，那它会等待，此时会释放锁，那么线程B获得锁并且也会执行wait方法，两个加线程一起等待被唤醒。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后B再执行。如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行。）</p>
<pre><code class="language-java">class ProducerCustomer {
    private int num;
    
    public synchronized void product() throws InterruptedException {
        while (num &gt; 0) { // 使用 while 防止虚假唤醒
            this.wait(); // 等待时释放锁
        }
        num++;
        System.out.println(Thread.currentThread().getName() + &quot; --&gt; &quot; + num);
        this.notifyAll();
    }
    
    public synchronized void custom() throws InterruptedException {
        while (num == 0) {
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName() + &quot; --&gt; &quot; + num);
        this.notifyAll();
    }
}
</code></pre>
<h2><a id="juc%E7%89%88%E6%9C%AC%EF%BC%88-lock-await-signal%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JUC 版本（<code>Lock</code> <code>await</code> <code>signal</code>）</h2>
<p>使用 Lock 加锁, Condition 对象中的 <code>await</code> 和 <code>signal</code> / <code>SignalAll</code> 进行等待和唤醒</p>
<pre><code class="language-java">class ProducerCustomerJUC {
    private int num = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    
    public void product() {
        lock.lock();
        try {
            while (num &gt; 0) condition.await();
            num++;
            System.out.println(Thread.currentThread().getName() + &quot; --&gt; &quot; + num);
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
    public void custom() {
        lock.lock();
        try {
            while (num == 0) condition.await();
            num--;
            System.out.println(Thread.currentThread().getName() + &quot; --&gt; &quot; + num);
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227359619314.html">单例模式</a></h1>
			<p class="meta"><time datetime="2021-06-03T23:59:21+08:00" 
			pubdate data-updated="true">2021/06/03</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F">饿汉式</a></li>
<li><a href="#dcl%E6%87%92%E6%B1%89%E5%BC%8F">DCL 懒汉式</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%EF%BC%88%E5%8D%95%E4%BE%8B%E6%8C%81%E6%9C%89%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89">静态内部类单例（单例持有者模式）</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88%E6%9C%80%E5%AE%89%E5%85%A8%EF%BC%8C%E6%9C%80%E6%8E%A8%E8%8D%90%EF%BC%89">使用枚举类（最安全，最推荐）</a></li>
</ul>
</div>
<h2><a id="%E9%A5%BF%E6%B1%89%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>饿汉式</h2>
<pre><code class="language-java">class Singleton {
    private final static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
</code></pre>
<h2><a id="dcl%E6%87%92%E6%B1%89%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DCL 懒汉式</h2>
<p>为什么必须是 <code>volatile</code> ？<br />
<code>new SingletonV2();</code> 执行的时候分为三步：<br />
1⃣️：分配内存空间<br />
2⃣️：执行构造器，初始化对象<br />
3⃣️：将引用指向这个空间<br />
然而由于指令重排，实际执行顺序可能是 1⃣️ -&gt; 3⃣️ -&gt; 2⃣️，当一个线程已经执行完 3⃣️，还没有执行 2⃣️ 时，这时引用已经指向了堆内存一块地址，但是这个地址还没有执行构造器初始化。另一个线程进入方法直接判断 <code>instance != null</code>，直接把这个引用返回接着去用了，就会发生问题，所以必须加 <code>volatile</code> 防止指令重排。</p>
<pre><code class="language-java">class SingletonV2 {
    // 必须是 volatile
    private volatile static SingletonV2 instance = null;
    private SingletonV2() {}

    public static SingletonV2 getInstance() {
        // 该处判断，主要作用是提升性能, 因为如果没有该处判断，会直接去获取锁对象，再判断是否已经创建对象
        if (instance == null) {
            //将当前类作为锁对象，获取该锁后执行该部分范围的代码逻辑
            synchronized (SingletonV2.class) {
                if (instance == null) {
                    instance = new SingletonV2();
                }
            }
        }

        return instance;
    }
}
</code></pre>
<h2><a id="%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%EF%BC%88%E5%8D%95%E4%BE%8B%E6%8C%81%E6%9C%89%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态内部类单例（单例持有者模式）</h2>
<p>原理：JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。这样就保证懒汉式懒加载的效果，同时又拥有了饿汉式线程安全的优点。</p>
<pre><code class="language-java">class SingletonV3 {
    
    private SingletonV3(){}
    
    private static class InstanceHolder {
        private final static SingletonV3 singletonV3 = new SingletonV3();
    }
    
    public SingletonV3 getInstance() {
        return InstanceHolder.singletonV3;
    }
}
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88%E6%9C%80%E5%AE%89%E5%85%A8%EF%BC%8C%E6%9C%80%E6%8E%A8%E8%8D%90%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用枚举类（最安全，最推荐）</h2>
<p>三种单例模式都不是绝对安全的：</p>
<ul>
<li>用私有化构造器并不保险，因为它抵御不了反射攻击</li>
<li>序列化后再反序列化，得到的对象就会改变，也不安全</li>
</ul>
<p>枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式，因为 Java 底层不允许通过反射创建枚举类，newInstance 创建对象时，会检查该类<strong>是否ENUM修饰</strong>，如果是则抛出异常，反射失败。同时，它也是序列化安全的</p>
<pre><code class="language-java">enum SingletonV4 {
    INSTANCE;
}
</code></pre>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1497592">Java单例模式的7种写法中，为何用Enum枚举实现被认为是最好的方式？</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227146556632.html">Stram 流计算</a></h1>
			<p class="meta"><time datetime="2021-06-03T18:04:15+08:00" 
			pubdate data-updated="true">2021/06/03</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#stream">Stream</a></li>
<li><a href="#parallelstream">parallelStream</a>
<ul>
<li><a href="#forkjoin">ForkJoin</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="stream" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stream</h2>
<p>Stream 使用一种类似 SQL 语句的直观方式，来对 Java 集合进行操作。</p>
<pre><code class="language-java">User a1 = new User(1, &quot;a&quot;, 21);
User a2 = new User(2, &quot;b&quot;, 22);
User a3 = new User(3, &quot;c&quot;, 23);
User a4 = new User(4, &quot;d&quot;, 24);
User a5 = new User(5, &quot;e&quot;, 25);
User a6 = new User(6, &quot;f&quot;, 26);
List&lt;User&gt; users = Arrays.asList(a1, a2, a3, a4, a5, a6);
users.stream()
        .filter((u)-&gt;{return u.id % 2 == 0;})
        .filter((u)-&gt;{return u.age &gt; 23;})
        .map((u)-&gt;{
            u.name = u.name.toUpperCase();
            return u;
        })
        .sorted((u1, u2)-&gt;{return u2.compareTo(u1);})
        .forEach(System.out::println);
</code></pre>
<h2><a id="parallelstream" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>parallelStream</h2>
<p>并行流内部默认使用了 forkjoin，默认的线程数量就是处理器数量，parallelStream 适用的场景是CPU密集型</p>
<pre><code class="language-java">long sum = LongStream.rangeClosed(0L,10_0000_0000L).parallel().reduce(0, Long::sum); // Long::sum 方法引用
</code></pre>
<h3><a id="forkjoin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ForkJoin</h3>
<p>Fork/Join 框架的核心是采用分治法的思想，将一个大任务拆分为若干互不依赖的子任务，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务。同时，为了最大限度地提高并行处理能力，采用了工作窃取算法来运行任务，也就是说当某个线程处理完自己工作队列中的任务后，尝试当其他线程的工作队列中窃取一个任务来执行，直到所有任务处理完毕。所以为了减少线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p><img src="media/16227169516018/16227193640438.jpg" alt="" class="mw_img_center" style="width:562px;display: block; clear:both; margin: 0 auto;" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227134041299.html">函数式接口</a></h1>
			<p class="meta"><time datetime="2021-06-03T17:43:24+08:00" 
			pubdate data-updated="true">2021/06/03</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"></div>
<p>只有一个方法的接口，配合 lambda 表达式可以简化编程模型</p>
<ol>
<li>
<p><code>Function</code> 函数式接口，一个输入，一个返回</p>
<pre><code class="language-java">// Function&lt;String, String&gt; function = new Function&lt;String, String&gt;() {
//     @Override
//     public String apply(String s) {
//         return s + &quot;_funtion&quot;;
//     }
// };
Function&lt;String, String&gt; function = (s) -&gt; { return s + &quot;_funtion&quot;; }; // 使用 lambda
System.out.println(function.apply(&quot;hello&quot;)); // hello_funtion
</code></pre>
</li>
<li>
<p><code>Predicate</code> 断定式接口，一个输入，返回布尔</p>
</li>
<li>
<p><code>Consumer</code> 消费型接口，只有输入，无返回</p>
</li>
<li>
<p><code>Supplier</code> 供给型接口，无输入，有返回</p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227100604511.html">线程池</a></h1>
			<p class="meta"><time datetime="2021-06-03T16:47:40+08:00" 
			pubdate data-updated="true">2021/06/03</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95">三个方法</a></li>
<li><a href="#%E4%B8%83%E4%B8%AA%E5%8F%82%E6%95%B0">七个参数</a></li>
<li><a href="#%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5">四种拒绝策略</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F">如何确定核心线程池数量</a></li>
</ul>
</div>
<p>池化技术：事先准备好一些资源，用的时候拿去，用完还回来<br />
池化技术的好处:降低资源消耗 (每次创建、销毁十分浪费资源)、提高响应速度、方便管理。</p>
<h2><a id="%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三个方法</h2>
<pre><code class="language-java">ExecutorService executor1 = Executors.newSingleThreadExecutor(); // 单个线程的线程池
ExecutorService executor2 = Executors.newFixedThreadPool(5); // 指定数量线程的线程池
ExecutorService executor3 = Executors.newCachedThreadPool(); // 可伸缩的线程池
</code></pre>
<h2><a id="%E4%B8%83%E4%B8%AA%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七个参数</h2>
<p>Executors 三个方法底层都是返回一个 ThreadPoolExecutor 对象 。我们不要使用Executors 的方式创建，可能会导致 OOM，要通过底层 ThreadPoolExecutor 的方式</p>
<pre><code class="language-java">ExecutorService executor4 = new ThreadPoolExecutor(
                2, // 默认有 2 个线程
                5, // 最多有 5 个线程
                3, // 非默认线程等待 3s 后销毁
                TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(3), // 默认线程满了后，新请求在队列等待，队列满了后开启新线程
                Executors.defaultThreadFactory(), 
                new ThreadPoolExecutor.AbortPolicy() // maximumPoolSize 和队列都满了，触发拒绝策略);
</code></pre>
<h2><a id="%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四种拒绝策略</h2>
<pre><code class="language-java">AbortPolicy // 丢掉任务，抛出异常
CallerRunPolicy // 返回给发出请求的线程执行，例如返回给 main 线程执行
DiscardPolicy // 丢掉异常，不抛出异常
DiscardOldestPolicy // 队列满了，尝试和最早的竞争，不抛出异常
</code></pre>
<h2><a id="%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何确定核心线程池数量</h2>
<p>线程数=cpu可用核心数/（1-阻塞系数），其中阻塞系数的取值在[0,1]之间。计算密集型任务的阻塞系数为0，而IO密集型任务的阻塞系数则接近1。一般，我们让线程执行的任务是比较复杂的，不会是单一的计算密集型任务，或者单一的IO密集型任务，通常会夹杂着。那么就需要我们去计算阻塞系数了。阻塞系数的定义就是执行该任务阻塞的时间与（阻塞时间+计算时间）的比值，也就是w/(w+c)。</p>
<p>一般经验： IO密集型：2倍cpu可用线程数；计算密集型：cpu可用核数</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16227068332225.html">阻塞队列</a></h1>
			<p class="meta"><time datetime="2021-06-03T15:53:53+08:00" 
			pubdate data-updated="true">2021/06/03</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#blockingqueue">BlockingQueue</a>
<ul>
<li><a href="#%E5%9B%9B%E7%BB%84api">四组 API</a></li>
</ul>
</li>
<li><a href="#synchronousqueue">SynchronousQueue</a></li>
</ul>
</div>
<h2><a id="blockingqueue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BlockingQueue</h2>
<p><code>java.util.concurrent.BlockingQueue</code> 接口有以下阻塞队列的实现：<br />
FIFO 队列 ：<code>LinkedBlockingQueue</code>、<code>ArrayBlockingQueue</code>（固定长度）<br />
优先级队列 ：<code>PriorityBlockingQueue</code></p>
<p>提供了阻塞的 <code>take()</code> 和 <code>put()</code> 方法：如果队列为空 <code>take()</code> 将阻塞，直到队列中有内容；如果队列为满 <code>put()</code> 将阻塞，直到队列有空闲位置。</p>
<p><img src="media/16227068332225/16227076040995.jpg" alt="" class="mw_img_center" style="width:453px;display: block; clear:both; margin: 0 auto;" /></p>
<h3><a id="%E5%9B%9B%E7%BB%84api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四组 API</h3>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加</td>
<td><code>add()</code></td>
<td><code>offer()</code> (满后返回 false)</td>
<td><code>put()</code> (满后一直等待)</td>
<td><code>offer(e, timeout, TimeUnit)</code> (满后等待一段时间)</td>
</tr>
<tr>
<td>移出</td>
<td><code>remove()</code></td>
<td><code>poll()</code> （空时返回 null）</td>
<td><code>take()</code> (空时一直等待)</td>
<td><code>poll(timeout, TimeUnit)</code> (空时一直等待)</td>
</tr>
<tr>
<td>判断首元素</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2><a id="synchronousqueue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SynchronousQueue</h2>
<p>从效果上看，他的容量是 1，put了一个元素，必须先从里面 take 取出来，否则不能再继续 put 下一个元素<br />
但是实际上它不是一个真正的队列, 不存储元素，它维护一组线程，这些线程在等待着把元素加入或移出队列。put 和 take 都在等待，put 线程直接把它交付给 take 线程，省去了加入取出队列的延迟。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16226447097561.html">辅助类</a></h1>
			<p class="meta"><time datetime="2021-06-02T22:38:29+08:00" 
			pubdate data-updated="true">2021/06/02</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#countdownlatch">CountDownLatch</a></li>
<li><a href="#cyclicbarrier">CyclicBarrier</a></li>
<li><a href="#semaphore%CB%88-sem%C9%99f%C9%94%CB%90r">Semaphore ([ˈseməfɔːr])</a></li>
</ul>
</div>
<h2><a id="countdownlatch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CountDownLatch</h2>
<p>减法计数器，提供方法使计数器减1，以及等待计数器归零</p>
<pre><code class="language-java"> 
new CountDownLatch(int n) // 计数
countDownLatch.countDown(); // -1 操作
countDownLath.await(); // 等待计数器归零, 然后被唤醒再向下执行
</code></pre>
<h2><a id="cyclicbarrier" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CyclicBarrier</h2>
<p>允许一组线程全部到达共同屏障点后再继续执行。加法计数器</p>
<pre><code class="language-java">CyclicBarrier cb = new CyclicBarrier(7, () -&gt; {
// 表示当有 n 个线程到达后，执行后面的 Runnable
    System.out.println(&quot;7个线程都已经执行到 barrier 了&quot;);
});

for (int i = 0; i &lt; 7; i++) {
    new Thread(()-&gt;{
        System.out.println(&quot;第 &quot; + Thread.currentThread().getName() + &quot; 个线程将要执行到 barrier&quot;);
        try {
            cb.await(); // 线程到达这里，计数器 + 1 然后等待 n 个线程都到达后继续执行
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }, String.valueOf(i)).start();
}
// 第 0 个线程将要执行到 barrier
// 第 1 个线程将要执行到 barrier
// 第 2 个线程将要执行到 barrier
// 第 3 个线程将要执行到 barrier
// 第 4 个线程将要执行到 barrier
// 第 5 个线程将要执行到 barrier
// 第 6 个线程将要执行到 barrier
// 7个线程都已经执行到 barrier 了
</code></pre>
<h2><a id="semaphore%CB%88-sem%C9%99f%C9%94%CB%90r" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Semaphore ([ˈseməfɔːr])</h2>
<p>信号量，限流的时候可以用（例如下面代码模拟有3个停车位，6个车要进入）<br />
<code>acquire()</code> 如果大于 0 就 -1，如果等于 0 就等待<br />
<code>release()</code> 释放，将信号量 + 1，唤醒等待的进程</p>
<pre><code class="language-java">Semaphore semaphore = new Semaphore(3);
for (int i = 0; i &lt; 6; i++) {
    new Thread(()-&gt;{
        try {
            semaphore.acquire(); // 等待获得
            System.out.println(Thread.currentThread().getName() + &quot; 进入&quot;);
            TimeUnit.SECONDS.sleep(1);
            System.out.println(Thread.currentThread().getName() + &quot; 离开&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }, String.valueOf(i)).start();
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16226423231626.html">Callable & Futrue</a></h1>
			<p class="meta"><time datetime="2021-06-02T21:58:43+08:00" 
			pubdate data-updated="true">2021/06/02</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#future">Future</a></li>
<li><a href="#runnablefuture-futretask">RunnableFuture &amp; FutreTask</a></li>
<li><a href="#completablefuture">CompletableFuture</a></li>
</ul>
</div>
<p>之前创建线程的 2 种方式：一种是直接继承 <code>Thread</code>，另外一种就是实现 <code>Runnable</code> 接口。这 2 种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。<br />
<code>Callable</code> 和 <code>Runnable</code> 类似，都是多线程一种实现方式，但是可以有返回值，可以抛出异常，使用 <code>call()</code> 方法启动</p>
<h2><a id="future" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future</h2>
<p><code>Future</code> 就是对于具体的 <code>Runnable</code> 或者 <code>Callable</code> 任务的执行结果进行取消、查询是否完成、获取结果。</p>
<pre><code class="language-java">ExecutorService threadPool = Executors.newFixedThreadPool(2);
Future&lt;Integer&gt; future = threadPool.submit((Callable&lt;Integer&gt;) () -&gt; {
    Thread.sleep(2000);
    return 0;
});
System.out.println(future.get()); // 0
threadPool.shutdown();
</code></pre>
<h2><a id="runnablefuture-futretask" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RunnableFuture &amp; FutreTask</h2>
<p><code>RunnableFuture</code> 实现了 <code>Runnable</code> 接口和 <code>Future</code> 接口，而 <code>FutureTask</code> 实现了 <code>RunnableFuture</code> 接口。所以 <code>FutureTask</code> 既可以作为 <code>Runnable</code> 被线程执行，又可以作为 <code>Future</code> 得到 <code>Callable</code> 的返回值。</p>
<pre><code class="language-java">import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableTest {
    public static void main(String[] args) {
        // 实例化 Callable 子类对象
        MyThread myThread = new MyThread();
        // 使用 Callable 子类对象构造 FutureTask 对象，它是一个 Runnable 的实现类，所以可以使用 Thread 运行，
        FutureTask futureTask = new FutureTask(myThread);
        new Thread(futureTask, &quot;callable&quot;).start();

        // FutureTask 同时也时 Future 的实现类，所以可以对任务进行取消、查询是否完成、获取结果
        try {
            String result = (String) futureTask.get(); // 这里可能产生阻塞
            System.out.println(result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class MyThread implements Callable&lt;String&gt; {
    @Override
    public String call() throws Exception {
        return &quot;hello Callable.&quot;;
    }
}
</code></pre>
<h2><a id="completablefuture" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CompletableFuture</h2>
<p>原始 <code>Future</code> 可以对执行的线程进行管理结果查询等（配合 <code>Callable</code>），但是查询结果需要阻塞等待线程执行完毕，效果不好。<br />
从 Java 8 开始引入了 <code>CompletableFuture</code>，它针对 <code>Future</code> 做了改进，可以事先定义好回调方法，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<pre><code class="language-java">CompletableFuture.supplyAsync(Supplier).thenAccept(Consumer).exceptionally(Function);
// 传入的 supplyAsync 对象在内部会被转成一个 Runnable 线程执行
// 执行完毕自动调用 thenAccept 传入的 Consumer
// 出现异常自动调用 exceptionally 传入的 Function
</code></pre>
<ul>
<li>使用</li>
</ul>
<pre><code class="language-java">CompletableFuture completableFuture = CompletableFuture.supplyAsync(() -&gt; {
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;hello completableFuture&quot;);
    return 1024;
}).thenAccept((t) -&gt; { // 成功执行完，自动调用这个
    System.out.println(t);
}).exceptionally((e)-&gt;{
    System.out.println(e);
    return null;
});

System.out.println(&quot;hello main1&quot;);
TimeUnit.SECONDS.sleep(2);
System.out.println(&quot;hello main2&quot;);

// 结果
// hello main1
// hello completableFuture // 线程执行时输出的语句
// 1024 // 线程正常执行完，自动调用 Consumer 输出的语句
// hello main2
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16226261701341.html">JUC 容器</a></h1>
			<p class="meta"><time datetime="2021-06-02T17:29:30+08:00" 
			pubdate data-updated="true">2021/06/02</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a></li>
<li><a href="#copyonwritearrayset">CopyOnWriteArraySet</a></li>
<li><a href="#concurrenthashmap">ConcurrentHashMap</a></li>
</ul>
</div>
<h2><a id="copyonwritearraylist" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CopyOnWriteArrayList</h2>
<p>并发下 List 是线程不安全的, 如何解决:</p>
<ul>
<li>使用 <code>Vector</code>, 使用了 <code>synchronized</code> 方法, 为了防止遍历时容器被修改报错, 即使遍历时容器我们也要加锁, 效率低</li>
<li>使用 <code>Collections.synchronizedList(List)</code> 转换成安全的, 内部也使用了 <code>synchronized</code> 方法</li>
<li>JUC 解决方案 ( 推荐 ): 使用 <code>CopyOnWriteArrayList</code>, 有写操作的时候会 copy 一份数据，然后写完再设置成新的数据, 使得迭代时其他线程可以增删元素, 并且使用 lock, 保证线程安全, 由于读取和写的内存不是同一块, 解决了遍历时需要加锁的问题.</li>
</ul>
<p><code>CopyOnWriteArrayList</code> 缺点:</p>
<ul>
<li>比较耗费内存</li>
<li>只能保证数据的最终一致性，不能保证数据的实时一致性</li>
</ul>
<h2><a id="copyonwritearrayset" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CopyOnWriteArraySet</h2>
<p>并发下 Set 是不安全的, 和 List 解决方案类似:</p>
<ul>
<li>使用 <code>Collections.synchronizedSet(Set)</code> 转换成安全的, 内部使用 <code>synchronized</code> 方法</li>
<li>JUC 解决方案: 使用 <code>CopyOnWriteArraySet</code></li>
</ul>
<p><strong>hashSet 底层是 hashMap</strong>: 利用了 map 的 key 是无法重复来实现的, 把值当作 map 的key 存起来, value 是一个全局常量</p>
<pre><code class="language-java">private static final Object PRESENT = new Object();

public HashSet() {
    map = new HashMap&lt;&gt;();
}

public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
</code></pre>
<h2><a id="concurrenthashmap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ConcurrentHashMap</h2>
<p>HashMap 线程不安全, 解决方案:</p>
<ul>
<li>使用 <code>Collections.synchronizedMap(Map)</code></li>
<li>JUC 解决方案: 使用 <code>ConcurrentHashMap</code>: 它有多个段，每个段下面都是一个<code>Hashtable</code>（相似），所以每个段上都有一把锁，各个段之间的锁互不影响，可以实现并发操作。</li>
</ul>
<p><img src="media/16226261701341/16226420497103.jpg" alt="" /></p>
<p>Jdk 1.8 中， ConcurrentHashMap 取消了 segment 分段锁，而采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构一样，数组 + 链表/红黑二叉树。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升N倍。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16226256624681.html">锁🔒</a></h1>
			<p class="meta"><time datetime="2021-06-02T17:21:02+08:00" 
			pubdate data-updated="true">2021/06/02</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%85%AC%E5%B9%B3%E9%94%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">公平锁 &amp; 非公平锁</a></li>
<li><a href="#%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81">乐观锁 &amp; 悲观锁</a></li>
<li><a href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88spin-lock%EF%BC%89">自旋锁（spin lock）</a>
<ul>
<li><a href="#%E8%87%AA%E6%97%8B%E9%94%81%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%90%97%EF%BC%9F">自旋锁是乐观锁吗？</a></li>
</ul>
</li>
<li><a href="#lock">Lock</a>
<ul>
<li><a href="#reentrantlock%EF%BC%88%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%89">ReentrantLock（重入锁）</a></li>
<li><a href="#readwritelock%EF%BC%88%E8%AF%BB%E5%86%99%E9%94%81%E3%80%81%E7%8B%AC%E5%8D%A0%E9%94%81%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%89">ReadWriteLock（读写锁、独占锁、共享锁）</a></li>
</ul>
</li>
<li><a href="#synchronized">synchronized</a>
<ul>
<li><a href="#%E6%97%A0%E9%94%81%E5%81%8F%E5%90%91%E9%94%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</a></li>
<li><a href="#synchronized%E9%94%81%E5%8D%87%E7%BA%A7">synchronized 锁升级</a></li>
<li><a href="#%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB">和 Lock 的区别</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a></li>
</ul>
</div>
<p><strong>Blog: <a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></strong></p>
<h2><a id="%E5%85%AC%E5%B9%B3%E9%94%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>公平锁 &amp; 非公平锁</h2>
<ul>
<li>公平锁：公平，不可以插队</li>
<li><strong>非公平锁</strong>：不公平，可以插队，Java 默认</li>
</ul>
<h2><a id="%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>乐观锁 &amp; 悲观锁</h2>
<ul>
<li>
<p>乐观锁</p>
<p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。乐观锁也是通过 CAS 操作实现的。</p>
</li>
<li>
<p>悲观锁</p>
<p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java 中的悲观锁就是 Synchronized, <strong>AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock</strong>。</p>
</li>
</ul>
<h2><a id="%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88spin-lock%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自旋锁（spin lock）</h2>
<p>如果获取不到锁，它们只需要等一等（自旋），等锁被释放后即可立即获取锁，这样就避免用户线程和内核的切换的消耗，使用 CAS 实现。</p>
<pre><code class="language-java">class SpinLock {
    private AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();

    public void lock() {
        Thread thread = Thread.currentThread();
        while(!atomicReference.compareAndSet(null, thread)); // 没有被锁住的时候，应该是 null
    }
    public void unlock() {
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread, null); // 如果是当前线程获得锁，设置成 null
    }
}
</code></pre>
<h3><a id="%E8%87%AA%E6%97%8B%E9%94%81%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自旋锁是乐观锁吗？</h3>
<p><strong>不是。乐观锁其实是无锁，自旋锁只是在实现的时候利用了乐观锁来实现。应该站在应用层分析，看它们是如何锁住应用数据的，而不是站在底层看抢占锁的过程。如果一个线程尝试获取锁时，发现已经被占用，它是否继续读取数据，还是等后续要更新时再决定要不要重试。其实自旋锁对应用数据的读取操作都被挡住了。</strong></p>
<h2><a id="lock" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lock</h2>
<p><code>java.util.concurrent.locks</code> 三个实现类: <code>ReentrantLock</code>, <code>ReentrantReadWriteLock.ReadLock</code>, <code>ReentrantReadWriteLock.WriteLock</code></p>
<ul>
<li>如何使用</li>
</ul>
<pre><code class="language-java">lock.lock(); // 加锁
try {
    // 业务代码
} catch (Exception e) {
    e.printStackTrace();
} finally {
    lock.unlock(); // 解锁
}
</code></pre>
<h3><a id="reentrantlock%EF%BC%88%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ReentrantLock（重入锁）</h3>
<p>重入锁、递归锁，Java 内置的锁（synchronized、Lock）都是重入锁。<br />
锁的操作粒度是线程,而不是调用，同一个线程再次进入同步代码的时候，可以使用自己已经获取到的锁。</p>
<h3><a id="readwritelock%EF%BC%88%E8%AF%BB%E5%86%99%E9%94%81%E3%80%81%E7%8B%AC%E5%8D%A0%E9%94%81%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ReadWriteLock（读写锁、独占锁、共享锁）</h3>
<p>读写锁，更加细粒度的控制。一对关联的锁，一个用于只读，一个用于写入。读锁可以共享，写锁只有一个线程可以获得。(可以同时读，不可以同时写，也不可以同时读写)<br />
语义与 <code>ReentrantLock</code> 类似，也是重入锁，唯一实现类是 <code>ReentrantReadWriteLock</code></p>
<pre><code class="language-java">ReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.writeLock(); // 获得写锁（独占锁）
rwLock.readLock(); // 获得读锁（共享锁）
</code></pre>
<h2><a id="synchronized" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>synchronized</h2>
<p>JDK 6 优化了 synchronized，将之前的重量级锁改为锁升级机制</p>
<h3><a id="%E6%97%A0%E9%94%81%E5%81%8F%E5%90%91%E9%94%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</h3>
<p><strong>无锁</strong>：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，例如乐观锁。<br />
<strong>偏向锁</strong>：（当一个线程访问同步代码块并获取锁时，会记住这个线程 ID。当这个线程再次获取锁的时候，就可以直接获取资源。只需比较 ThreadID）<br />
<strong>轻量级锁</strong>：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁（自旋锁），不会阻塞，从而提高性能。（自旋）<br />
<strong>重量级锁</strong>：等待锁的线程都会进入阻塞状态。当轻量级锁自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。（依赖OS的互斥锁 mutex lock）</p>
<h3><a id="synchronized%E9%94%81%E5%8D%87%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>synchronized 锁升级</h3>
<p>初次执行到 synchronized 代码块的时候，锁对象变成偏向锁，执行完同步代码块后，线程并不会主动释放偏向锁。</p>
<p>当第二次到达同步代码块时，线程会判断此时持有锁的线程ID是否就是自己，如果是则直接往下执行，性能极高。</p>
<p>但是，一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁），没有抢到锁的线程将自旋。抢到锁后线程将当前锁的持有者信息修改为自己。</p>
<p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁，当后续线程尝试获取锁时，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p>
<p>⚠️：<strong>当第二个线程执行到这个 synchronized 代码块时是否一定会发生锁竞争然后升级为轻量级锁呢？</strong></p>
<p>线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活。如果线程A仍然存活，将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋。但是如果判断结果是线程A不存在了，则线程B持有此偏向锁，锁不升级。</p>
<h3><a id="%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>和 Lock 的区别</h3>
<p><code>synchronized</code> 无法判断锁的状态<br />
<code>synchronized</code> 会自动释放锁; Lock 必须手动释放<br />
<code>synchronized</code> 获取不到锁会阻塞; Lock 可以使用 <code>tryLock()</code> 尝试获取不到不会一直等待<br />
<code>synchronized</code> 适合锁少量代码同步; Lock 适合大量同步代码<br />
<code>synchronized</code> 会锁升级，但是是不可逆的，一旦升级为重量级锁，就回不去了，如果并发量不稳定，可能造成性能损失<br />
<code>synchronized</code> 由 JVM 实现，底层锁住的是对象头，<code>Lock</code> 由 JDK 实现，依赖 AQS，通过 state 判断</p>
<p>synchronized 锁的是方法的调用者 (<code>this</code>), 静态方法锁的是 Class 对象, 所有的实例共享一把锁</p>
<p>分别使用 <code>synchronized</code> 和 <code>Lock</code> 实现 <a href="16227416766193.html">生产者消费者</a><br />
使用 Condition 有什么好处: 可以使用多个 Condition 达到精准通知某个线程的目的</p>
<pre><code class="language-java">class ConditionTest {
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private int num = 1; // 默认第一个先执行
    
    public void show1() {
        lock.lock();
        try {
            while (num != 1) condition1.await(); // 1等待
            System.out.println(Thread.currentThread().getName());
            num = 2;
            condition2.signal(); // 执行完通知2
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
    public void show2() {
        lock.lock();
        try {
            while (num != 2) condition2.await(); // 2等待
            System.out.println(Thread.currentThread().getName());
            num = 1;
            condition1.signal(); // 执行完通知1
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<pre><code class="language-java">// 调用
ConditionTest conditionTest = new ConditionTest();
new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) conditionTest.show1(); }, &quot;A&quot;).start();
    
new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) conditionTest.show2(); }, &quot;B&quot;).start();
// 结果: A B A B A B A B .....
</code></pre>
<h2><a id="%E6%AD%BB%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>死锁</h2>
<p>尝试获取对方的锁，如何排查？</p>
<ol>
<li>查看日志</li>
<li><strong>查看堆栈信息</strong>（使用 <code>jps -l</code> 查看 java 进程号、使用 <code>jstack 进程号</code> 查看进程信息）</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16226153690757.html">线程进程</a></h1>
			<p class="meta"><time datetime="2021-06-02T14:29:29+08:00" 
			pubdate data-updated="true">2021/06/02</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B">线程和进程</a>
<ul>
<li><a href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C">并发和并行</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81">线程状态</a></li>
<li><a href="#wait-sleep">wait &amp; sleep</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概念</h2>
<p>Jdk 三个包: <code>java.util.concurrent</code> 包以及这个包下面的 atomic 和 lock 包里的工具</p>
<h2><a id="%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程和进程</h2>
<p>一个进程可以包含多个线程, 至少包含一个<br />
对于 Java 而言, 默认有 2 个线程: main 和 GC, 开启线程的方式: <code>Thread</code> <code>Callable</code> <code>Runnable</code>, 但最终时通过本地方法调用本地 C++ 方法.</p>
<p>区别:</p>
<ul>
<li>资源: 进程时资源分配的基本单位, 线程不拥有资源</li>
<li>调度: 线程是独立调度的基本单位</li>
<li>开销: 创建销毁进程时, 会分配回收资源; 线程只需要设置少量寄存器, 开销小</li>
<li>通信: 线程间通过共享内存进行数据通信, 进程一般需要借助 IPC</li>
</ul>
<h3><a id="%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>并发和并行</h3>
<p>并发: 宏观上在同一段时间同时运行多个程序, 多线程操作同一个资源<br />
并行: 同一时刻能够运行多个指令, 需要硬件支持</p>
<h3><a id="%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程状态</h3>
<p><img src="media/16226153690757/16226167728821.jpg" alt="" class="mw_img_center" style="width:602px;display: block; clear:both; margin: 0 auto;" /></p>
<h3><a id="wait-sleep" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>wait &amp; sleep</h3>
<p>来自不同的类: wait 来自 Object; sleep 来自 Thread<br />
锁的释放: wait 会释放锁; sleep 不会释放<br />
使用范围不同: wait 必须在同步代码块中使用; sleep 可以在任何地方调用</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221777530736.html">6. 数组</a></h1>
			<p class="meta"><time datetime="2021-05-28T12:55:53+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">内存结构</a></li>
<li><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a></li>
<li><a href="#java-util-arrays%E5%B7%A5%E5%85%B7%E7%B1%BB">java.util.Arrays 工具类</a></li>
</ul>
</div>
<h2><a id="%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概述</h2>
<ul>
<li>数组存放的元素数据类型是统一的</li>
<li>地址空间连续</li>
<li>数组本身是<strong>引用类型</strong>, 元素可以是基本类型也可以是引用类型</li>
<li>长度一旦确定不能修改</li>
</ul>
<h2><a id="%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存结构</h2>
<p>栈 ( stack ): 存放局部变量, 对象的引用<br />
堆 ( heap ): 存放 new 出来的对象. eg. 对象, 数组<br />
方法区: 类信息 常量池 静态域 ...</p>
<h2><a id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一维数组</h2>
<ul>
<li>
<p>声明初始化: 一旦初始化完成, 长度就确定了. <code>[]</code> 放在类型后面和变量名后面都可以</p>
<pre><code class="language-java">// 静态初始化: 数组初始化和元素赋值同时进行
int[] is1 = new int[]{1, 2, 3};
int[] is2 = {1, 2, 3}; // 编译器能够推断 is2 的类型, 可以省略 new int[]
// int[] is; is = {1, 2, 3}; // 错误, 声明和赋值分开时, 编译器不能推断 is 类型, 不能省略 new int[]
// 动态初始化: 数组初始化和元素赋值分开进行
String[] ss = new String[5];
</code></pre>
</li>
<li>
<p>获取长度: 使用数组的 <code>length</code> 属性</p>
</li>
<li>
<p>默认初始值</p>
<ul>
<li>整型 (<code>byte</code> <code>short</code> <code>int</code> <code>long</code>): 0</li>
<li>浮点型 (<code>float</code> <code>double</code>): 0.0</li>
<li><code>char</code>: ascii 码为 0 的字符</li>
<li><code>boolean</code>: <code>false</code></li>
<li>引用数据类型: <code>null</code></li>
</ul>
</li>
</ul>
<h2><a id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二维数组</h2>
<ul>
<li>
<p>底层没有二维数组, 只不过一维数组的元素仍然是一个数组的引用</p>
</li>
<li>
<p>声明初始化</p>
<pre><code class="language-java">// 静态初始化
int[][] is = {{1, 2}, {3, 4, 5}};
int[][] is = new int[][]{{1, 2}, {3, 4, 5}};

// 动态初始化
String[][] ss = new String[3][2]; // 外层有 3 个元素, 每个元素引用的数组有 2 个元素
String[][] ss = new String[3][]; // 外层有 3 个元素, 每个元素引用需要后面定义
// String[][] ss = new String[][2]; // 错误
</code></pre>
</li>
</ul>
<h2><a id="java-util-arrays%E5%B7%A5%E5%85%B7%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>java.util.Arrays 工具类</h2>
<pre><code class="language-java">boolean equals(int[] a, int[] b) // 比较两个数组是否相等
String toString(int[] a) // 输出数组信息
void fill(int[] a, int val) // 用 val 填充 a
void sort(int[] a) // 排序, 默认用快排
int binarySearch(int[] a, int key) // 二分查找 key, 数组必须是有序的, 未找到返回负数
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221418018700.html">5. 分支循环</a></h1>
			<p class="meta"><time datetime="2021-05-28T02:56:41+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%88%86%E4%B9%8B%E7%BB%93%E6%9E%84">分之结构</a>
<ul>
<li><a href="#if-else">if...else...</a></li>
<li><a href="#switch-case">switch...case...</a></li>
</ul>
</li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">循环结构</a>
<ul>
<li><a href="#for">for</a></li>
<li><a href="#while">while</a></li>
<li><a href="#do-while">do...while</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="%E5%88%86%E4%B9%8B%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分之结构</h2>
<h3><a id="if-else" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>if...else...</h3>
<pre><code class="language-java">if(a) {
    xxxxx;
}

// 二选一
if(a) {
    xxxxx;
} else {
    xxxxx;
}

// 多选一
if(a) {
    xxxxx;
} else if(b) {
    xxxxx;
} else {
    xxxxx;
}
</code></pre>
<h3><a id="switch-case" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>switch...case...</h3>
<ul>
<li><code>switch</code> 中的表达式的类型只能是以下 6 种: <code>byte</code> <code>short</code> <code>char</code> <code>int</code> <code>枚举</code> <code>String</code></li>
<li><code>case</code> 后只能写常量, 不能是范围</li>
<li>当匹配到一个分支, 后面的分支不需要判断直接执行, 如果不想执行需要添加 <code>break</code></li>
</ul>
<pre><code class="language-java">switch(a) { // a 的类型只能是以下6种: byte short char int 枚举 String
    case b: // a == b
        xxxxx;
        break; // 不加 break 会不进行判断直接继续向下执行 case c 和 default 的代码
    case c: // a == c
        xxxxx;
    default: // 位置可任意
        xxxxx;
}
</code></pre>
<h2><a id="%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>循环结构</h2>
<p>① 初始化条件<br />
② 循环条件<br />
③ 迭代部分<br />
④ 循环体</p>
<h3><a id="for" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>for</h3>
<pre><code class="language-java">for ( ①; ②; ③ ) {
    ④;
}
</code></pre>
<h3><a id="while" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>while</h3>
<pre><code class="language-java">①
while ( ② ) { // 满足进入
    ④;
    ③;
}
</code></pre>
<h3><a id="do-while" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>do...while</h3>
<pre><code class="language-java">①
do {
    ④;
    ③;
} while ( ② ); // 满足再次进入
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221357067724.html">4. 运算符</a></h1>
			<p class="meta"><time datetime="2021-05-28T01:15:06+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">比较运算符</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li>
<li><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a></li>
</ul>
</div>
<h2><a id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算术运算符</h2>
<p><code>+ -</code>: 正 负<br />
<code>+</code>: 字符串连接<br />
<code>+ - * / %</code>: 加 减 乘 除 取模<br />
<code>++ --</code>: 自加 自减</p>
<pre><code class="language-java">int a = 10;
int b = a++; // 先运算赋值 后自加
System.out.println(b); // 10

a = 10;
int c = ++a; // 先自加 后运算赋值
System.out.println(c); // 11

// ++ -- 不会改变数据类型
char c1 = 'a';
System.out.println(++c1); // b
short s = 1;
System.out.println(++s); // 2
</code></pre>
<h2><a id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>赋值运算符</h2>
<p><code>=</code>: 支持连续赋值 <code>a = b = 1;</code><br />
<code>-= += /= *= ...</code>: 相等于 <code>a = a -+/* b</code>, <strong>不会改变数据类型</strong></p>
<pre><code class="language-java">char c2 = 'a';
// c2 = c2 + 2; // 编译不通过, 因为 byte short char 相互运算都转成 int 
c2 += 2; // 类型不改变
System.out.println(c2); // c

int i = 1;
i *= 0.1; // 可以编译通过, 会把结果 0.1 截断成 0 赋值给 i, 不改变 数据类型
System.out.println(i); // 0
</code></pre>
<h2><a id="%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>比较运算符</h2>
<p>结果都是 boolean 类型<br />
<code>== != &lt; &gt; &lt;= &gt;=</code> <code>instanceof</code></p>
<h2><a id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑运算符</h2>
<p>操作的是 boolean 类型<br />
<code>&amp; |</code>: 逻辑与 逻辑或<br />
<code>&amp;&amp; ||</code>: 短路与 短路或<br />
<code>! ^</code>: 逻辑非 逻辑异或(相同为假 不同为真)</p>
<h2><a id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>位运算符</h2>
<p>操作的是数值类型<br />
<code>&lt;&lt;</code>: 左移, 低位补 0, <strong>在一定范围内</strong>相等于  [ 原数 * 2^n ], 但当有可能出现符号改变的问题<br />
<code>&gt;&gt;</code>: 右移, 正数高位补 0, 负数高位补 1, 相等于原数 / 2^n<br />
<code>&gt;&gt;&gt;</code>: 无符号右移, 不管正负数, 高位都补 0<br />
<code>&amp; | ^</code>: 与 或 异或<br />
<code>~</code>: 取反, 按补码各位取反</p>
<h2><a id="%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三元运算符</h2>
<p><code>b ? a1 : a2</code>: 如果 <code>b == true</code> 则取 <code>a1</code>, 否则取 <code>a2</code><br />
<strong>要求a1和a2是相同数据类型, 如果不是就会转换</strong></p>
<pre><code class="language-java">System.out.println(true ? 1 : 2.0); // 输出 1.0
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221160561779.html">3. 数据类型</a></h1>
			<p class="meta"><time datetime="2021-05-27T19:47:36+08:00" 
			pubdate data-updated="true">2021/05/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">基本数据类型转换</a></li>
<li><a href="#string">String</a></li>
<li><a href="#%E8%BF%9B%E5%88%B6">进制</a></li>
</ul>
</div>
<h2><a id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据类型</h2>
<ul>
<li>基本数据类型 ( 8 种 )
<ul>
<li>数值型
<ul>
<li>整数类型:
<ul>
<li><code>byte</code>(8): 范围 -128 ~ 127</li>
<li><code>short</code>(16)</li>
<li><code>int</code>(32)</li>
<li><code>long</code>(64): 以 l 或 L 结尾, 有时不加也可以正常编译过, 是因为 <code>int</code> 转成了 <code>long</code>, 如果数字过大, 则会报错</li>
</ul>
</li>
<li>浮点类型
<ul>
<li><code>float</code>(32): 有效数字 7 位, 以 f 或 F 结尾</li>
<li><code>double</code>(64)</li>
</ul>
</li>
</ul>
</li>
<li>字符型 <code>char</code>(16): 使用 '' 定义, 只能 (且必须) 写一个字符, 转义字符也算一个字符</li>
<li>布尔型 <code>boolean</code>: true or false</li>
</ul>
</li>
<li>引用数据类型 ( 3 种 )
<ul>
<li>类 <code>class</code> (eg. <code>String</code>)</li>
<li>接口 <code>interface</code></li>
<li>数组 <code>[]</code></li>
</ul>
</li>
</ul>
<h2><a id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本数据类型转换</h2>
<ul>
<li>
<p>自动类型转换：容量小的数据类型自动转换为容量大的数据类型</p>
<ul>
<li>容量大小指的是, 表示数的范围大小, 不是内存占用大小, 比如: <code>float</code> 表示的范围比 <code>long</code> 大, 但 <code>long</code> 占用 64 bit, <code>long</code> 自动转成 <code>float</code></li>
<li><code>byte</code> / <code>short</code> / <code>char</code> 之间 ( 甚至同种类型 ) 做运算，结果为 <code>int</code> 型</li>
<li>整型常量默认位 <code>int</code>; 浮点型常量默认位 <code>double</code></li>
</ul>
</li>
<li>
<p>强制类型转换: 是自动类型转换的逆过程, 使用 “( )” 实现强转</p>
</li>
</ul>
<h2><a id="string" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>String</h2>
<ul>
<li>不是基本类型</li>
<li>可以和 8 种基本数据类型做运算 (只能是连接运算 <code>+</code>), 运算结果仍然是 <code>String</code></li>
<li><code>String</code> 转成基本类型不能使用 <code>int(&quot;xxx&quot;)</code>, 要使用包装类例如 <code>Integer.parseInt(&quot;xxx&quot;)</code></li>
</ul>
<h2><a id="%E8%BF%9B%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进制</h2>
<pre><code class="language-java">int n2 = 0b110;
int n8 = 01;
int n10 = 1;
int n16 = 0x110A;
</code></pre>
<ul>
<li>二进制: 以 <code>0b</code> <code>0B</code> 开头, 计算机底层以 <strong><a href="mweblib://15661155257627">补码</a></strong> 方式存储数据
<ul>
<li>正数: 补码 = 反码 = 原码</li>
<li>负数: 补码 = 反码 + 1</li>
</ul>
</li>
<li>八进制: 以 <code>0</code> 开头</li>
<li>十进制</li>
<li>十六进制: 以 <code>0x</code> <code>0X</code> 开头</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221150711459.html">2. 关键字</a></h1>
			<p class="meta"><time datetime="2021-05-27T19:31:11+08:00" 
			pubdate data-updated="true">2021/05/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%9D%E7%95%99%E5%AD%97%E6%A0%87%E8%AF%86%E7%AC%A6">关键字 保留字 标识符</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">命名规则</a></li>
</ul>
</div>
<h2><a id="%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%9D%E7%95%99%E5%AD%97%E6%A0%87%E8%AF%86%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关键字 保留字 标识符</h2>
<p>关键字（keyword）：被Java语言赋予了特殊含义，用做专门用途的字符（单词）<br />
保留字：现有Java版本尚未使用，但以后可能会使用的字符<br />
标识符（Identifier）：对各种变量、方法和类等命名的字符</p>
<ul>
<li>字母（大小写）、0-9、_、$</li>
<li>数字不可以开头</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>严格区分大小写，长度无限制</li>
<li>不能包含空格</li>
</ul>
<h2><a id="%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命名规则</h2>
<p>包名：多单词组成时所有字母都小写：xxxyyyzzz<br />
类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz<br />
变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz<br />
常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221094537419.html">1. Hello World</a></h1>
			<p class="meta"><time datetime="2021-05-27T17:57:33+08:00" 
			pubdate data-updated="true">2021/05/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#config">Config</a></li>
<li><a href="#jdk-jre-jvm">JDK JRE JVM</a></li>
<li><a href="#%E7%BC%96%E8%AF%91">编译</a></li>
</ul>
</div>
<h2><a id="config" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Config</h2>
<table>
<thead>
<tr>
<th>变量名</th>
<th>变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>JAVA_HOME</code></td>
<td>Java 安装路径</td>
</tr>
<tr>
<td><code>PATH</code></td>
<td><code>%JAVA_HOME%\bin</code></td>
</tr>
<tr>
<td><code>CLASSPATH</code></td>
<td><code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code></td>
</tr>
</tbody>
</table>
<h2><a id="jdk-jre-jvm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JDK JRE JVM</h2>
<p>JDK = JRE + Java 开发工具（javac java javadoc）<br />
JRE = JVM + Java 核心类<br />
<img src="media/16221094537419/16221148084817.jpg" alt="" style="width:1021px;" /></p>
<h2><a id="%E7%BC%96%E8%AF%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译</h2>
<p><img src="media/16221094537419/16221094887530.jpg" alt="" style="width:477px;" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221429228201.html">读取键盘</a></h1>
			<p class="meta"><time datetime="2021-05-28T03:15:22+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"></div>
<pre><code class="language-java">import java.util.Scanner;
Scanner scan = new Scanner(System.in)
String s = scan.next()
int i = scan.nextInt()
double d = scan.nextDouble()
boolean b = scan.nextBoolean()
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16223735897370.html">7. abstract & interface</a></h1>
			<p class="meta"><time datetime="2021-05-30T19:19:49+08:00" 
			pubdate data-updated="true">2021/05/30</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#abstract">abstract</a>
<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">抽象方法</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB">抽象类的匿名子类</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95">应用: 模版方法</a></li>
</ul>
</li>
<li><a href="#interface">interface</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a>
<ul>
<li><a href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF">接口的继承</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB">接口匿名实现类</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E4%B8%80%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8Fproxy">应用一: 代理模式 (Proxy)</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E4%BA%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">应用二: 工厂模式</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="abstract" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>abstract</h2>
<h3><a id="%E6%8A%BD%E8%B1%A1%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>抽象类</h3>
<p>当使用 <code>abstract</code> 修饰类后, 就不可以实例化, 但是一定有构造器, 便于子类实例化调用.<br />
开发中都会提供抽象类的子类, 让子类实例化, 提供相关操作.</p>
<h3><a id="%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>抽象方法</h3>
<ul>
<li>抽象方法没有方法体, 不能是 <code>private</code>, 不应该被调用, <strong>只能写在抽象类中 (抽象类中可以没有抽象方法)</strong>.</li>
<li><strong>抽象方法一定要在非抽象子类中实现</strong></li>
</ul>
<pre><code class="language-java">public abstract 返回类型 方法名(型参);
</code></pre>
<h3><a id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>抽象类的匿名子类</h3>
<pre><code class="language-java">Person p = new Person() { // Person 是抽象类
    @Override
    public void show() {
        System.out.println(&quot;hello&quot;);
    }
};

p.show(); // hello
</code></pre>
<h3><a id="%E5%BA%94%E7%94%A8%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用: 模版方法</h3>
<p>当功能一部分实现时确定的 (这部分步骤很固定通用), 一部分实现是不确定的. 这时可以把不确定的部分暴露出去, 让子类去实现.</p>
<h2><a id="interface" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>interface</h2>
<ul>
<li>Java 中, 接口和类是并列的两个结构</li>
<li>Java 没有多继承, <code>interface</code> 可以得到多继承的效果 (<strong>单继承, 多实现</strong>)</li>
<li>接口<strong>本质是规范</strong>, 契约等. 继承是一个 &quot;是不是&quot; 的关系, 而接口是 &quot;能不能&quot; 的关系</li>
<li>接口的实现体现了多态, 接口的实现子类可以赋值给接口的引用变量 (<code>C c = new D();</code> <code>C</code> 是接口, <code>D</code> 实现了 <code>C</code>)</li>
</ul>
<h2><a id="%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义</h2>
<ul>
<li>
<p>Jdk 7: 只能定义全局常量和抽象方法</p>
<ul>
<li>全局常量: <code>public static final</code>, 书写时可以省略, 效果不变</li>
<li>抽象方法: <code>public abstract</code></li>
<li><strong>接口不能定义构造器</strong>, 不可以实例化</li>
</ul>
<pre><code class="language-java">interface Flyable {
    public static final int MAX_SPEED = 7900;
    int MIN_SPEED = 1; // 可以省略 public static final

    public abstract void fly();
    void stop(); // 可以省略 public abstract
}
</code></pre>
</li>
<li>
<p>Jdk 8: 除了全局常量和抽象方法, 还可以定义静态方法和默认方法</p>
<pre><code class="language-java">interface Java8Interface {
    // 静态方法
    public static void method1() { // public 可以省略
        System.out.println(&quot;m1&quot;);
    }
    // 默认方法
    public default void method2() {
        System.out.println(&quot;interface m2&quot;);
    }
}
class SuperClass {
    public void method2() {
        System.out.println(&quot;super class m2&quot;)
    }
}
class SubClass extends SuperClass implements Java8Interface {
    // 无需实现静态和默认方法, 但是可以重写
}

... main {
    SubClass subClass = new SubClass();
    // 如果子类继承的父类和实现的接口中声明了同名同参的方法, 在没有重写的情况下, 默认调用父类的方法
    // 如果子类实现的多个接口中声明了同名同参的静态或默认方法, 子类必须重写
    subClass.method2(); // super class m2
    // subClass.method1(); // 接口的静态方法只能用接口调用
    Java8Interface.method1();
}
</code></pre>
</li>
</ul>
<h3><a id="%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口的继承</h3>
<pre><code class="language-java">interface A {
    void method1();
}
interface B {
    void method2();
}
interface C extends A, B { // 继承两个父接口, 里面实际有三个方法
    void method3();
}

class D implements C { // 需要实现 3 个方法
    @Override
    public void method1() {}
    @Override
    public void method2() {}
    @Override
    public void method3() {}
}
</code></pre>
<h3><a id="%E6%8E%A5%E5%8F%A3%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口匿名实现类</h3>
<p>和抽象类的匿名子类类似</p>
<pre><code class="language-java">new A(){
    @Override
    public void method1() {
        System.out.println(&quot;hi&quot;);
    }
}.method1(); // hi
</code></pre>
<h3><a id="%E5%BA%94%E7%94%A8%E4%B8%80%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8Fproxy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用一: 代理模式 (Proxy)</h3>
<p>代理模式就是为其他对象提供一种代理以控制对这个对象的访问. 分为静态代理和动态代理 ( 应用场景: 安全代理 / 远程代理 / 延迟加载 )</p>
<p>静态代理举例:</p>
<pre><code class="language-java">interface NetWork {
    void browse();
}
class Server implements NetWork {
    @Override
    public void browse() {
        System.out.println(&quot;Server browse...&quot;);
    }
}
class ProxyServer implements NetWork {
    private Server server;
    public ProxyServer(Server server) {
        this.server = server;
    }
    @Override
    public void browse() {
        System.out.println(&quot;check...&quot;);
        server.browse();
        System.out.println(&quot;ok.&quot;);
    }
}
</code></pre>
<p>调用</p>
<pre><code class="language-java">Server server = new Server();
ProxyServer proxyServer = new ProxyServer(server);
proxyServer.browse();
</code></pre>
<p>结果</p>
<pre><code class="language-plain_text">check...
Server browse...
ok.
</code></pre>
<h3><a id="%E5%BA%94%E7%94%A8%E4%BA%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用二: 工厂模式</h3>
<p>实现创建者与调用着的分离, 将创建对象的具体过程屏蔽隔离起来, 达到提高灵活性的目的.<br />
分类: 简单工厂模式, 工厂方法模式, 抽象工厂模式</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16222923817986.html">6. static & final</a></h1>
			<p class="meta"><time datetime="2021-05-29T20:46:21+08:00" 
			pubdate data-updated="true">2021/05/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#static">static</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">静态变量</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97">静态代码块</a></li>
</ul>
</li>
<li><a href="#final">final</a></li>
</ul>
</div>
<h2><a id="static" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>static</h2>
<p>如果我们希望无论创建多少个实例, 某些特定的属性在内存中只存在一份. 例如每个中国人的国籍都是 <code>中国</code>, 不必每个对象都有一个单独的国籍属性.</p>
<p>可以修饰的是属性 / 方法 / 代码块 / 内部类</p>
<h3><a id="%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态变量</h3>
<p>实例变量: 非静态变量, 每个实例都有一个独立的属性<br />
静态变量: 用 <code>static</code> 修饰的变量, 是共享的属性, 在内存中只有一份. 随着类加载, 存在于方法区的静态域. 可以通过 <code>类.属性</code> 调用</p>
<pre><code class="language-java">public class StaticTest {
    public static void main(String[] args) {
        Chinese c1 = new Chinese();
        Chinese c2 = new Chinese();
        c1.name = &quot;a&quot;;
        c1.nation = &quot;CHN&quot;;
        c2.name = &quot;b&quot;;
        c2.nation = &quot;CHINA&quot;;
        System.out.println(c1.nation); // CHINA
        System.out.println(Chinese.nation); // CHINA
    }
}
class Chinese {
    String name;
    static String nation;
}
</code></pre>
<h3><a id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态方法</h3>
<p>随着类的加载而加载, 可以通过类直接调用<br />
静态方法中只能调用静态方法或静态变量; 非静态方法既可以调用静态也可以调用非静态方法和变量<br />
静态方法中不能有 <code>this</code> <code>super</code> 关键字</p>
<h3><a id="%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态代码块</h3>
<ul>
<li>静态代码块随着类的加载而加载, 且只加载一次; 非静态代码块每次创建对象时都会加载一次</li>
<li>静态代码块只能使用静态变量方法</li>
<li>静态代码块早于非静态代码块的执行</li>
</ul>
<h2><a id="final" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>final</h2>
<p>意为最终的版本, 可以用来修饰类 属性 方法</p>
<ul>
<li>修饰类: 这个类就不能被继承</li>
<li>修饰方法: 这个方法不能被重写</li>
<li>修饰属性: 这个属性就是常量 (没有默认值), 一旦初始化 (显式赋值 代码块 构造器) 就不能更改</li>
<li>修饰型参或变量时, 方法内部只读, 不可再更改</li>
</ul>
<p><strong><code>static final</code></strong>: 全局静态常量, 内存只有一份, 且不能更改. eg. <code>Math.PI</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16222741834695.html">4. 多态</a></h1>
			<p class="meta"><time datetime="2021-05-29T15:43:03+08:00" 
			pubdate data-updated="true">2021/05/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#instanceof">instanceof</a></li>
</ul>
</div>
<h2><a id="%E5%A4%9A%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多态</h2>
<p>可以理解为一个对象的多种形态<br />
多态的形式：父类的引用指向子类的对象</p>
<pre><code class="language-java">PClass p = new SubClass();
</code></pre>
<p>多态的应用（虚拟方法调用）：编译时只能调用父类的方法，执行时调用子类重写的方法。编译看左边，执行看右边<br />
多态的前提：有继承关系，有方法重写</p>
<p>注意：<strong>对象多态性不是用于属性</strong>，子类和父类属性重名时，运行时访问的是父类的属性</p>
<p>多态是运行时行为</p>
<h2><a id="instanceof" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>instanceof</h2>
<p>如果想在多态时调用子类的特有方法，需要将父类引用向下转型成子类</p>
<pre><code class="language-java">public class Animal {
    public void eat() {
        System.out.println(&quot;animal eat&quot;);
    }

    public static void main(String[] args) {
        Animal animal = new Dog();
        // dog.walk(); // error
        if (animal instanceof Dog) {
            Dog dog = (Dog)animal;
            dog.walk();
        }
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println(&quot;dog eat&quot;);
    }

    public void walk() {
        System.out.println(&quot;dog walk&quot;);
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221979238015.html">3. 继承</a></h1>
			<p class="meta"><time datetime="2021-05-28T18:32:03+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#object">Object</a></li>
<li><a href="#%E9%87%8D%E5%86%99overrideoverwrite">重写 (override/overwrite)</a></li>
<li><a href="#%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B">子类实例化过程</a></li>
</ul>
</div>
<h2><a id="%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概述</h2>
<pre><code class="language-java">class A extends B { }
</code></pre>
<ul>
<li>子类可以获得父类中有私有的属性或方法，但由于封装性的设计，不可以直接调用</li>
<li>子类是对父类功能的 “扩展”，不是父类的子集</li>
<li>Java 一个类只能继承一个父类, 但可以有多个子类 （单继承 多实现）</li>
<li>好处
<ul>
<li>减少代码冗余, 提高复用性</li>
<li>便于功能扩展</li>
<li>为多态提供了前提</li>
</ul>
</li>
</ul>
<h2><a id="object" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object</h2>
<p>所有的类都直接或间接的继承 <code>java.lang.Object</code> 类</p>
<h2><a id="%E9%87%8D%E5%86%99overrideoverwrite" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重写 (override/overwrite)</h2>
<p>在继承的基础之上，子类在获取了父类的结构以后，可以对父类中同名的方法 ( 非 <code>private</code> )进行 “重构”</p>
<ul>
<li>方法名，形参列表形同</li>
<li>方法的返回值需要是父类返回值类或父类返回值类子类</li>
<li>权限修饰符不小于父类；异常类型不大于父类</li>
<li>两个方法要同为 <code>static</code> 或同为非 <code>static</code></li>
</ul>
<h2><a id="%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>子类实例化过程</h2>
<ul>
<li>从结果上来看，子类继承父类以后，就获取了父类的属性方法，创建子类的对象，的堆空间中，就会加载所有父类声明的属性。</li>
<li>从过程来看，当我们通过子类的构造器创建对象的时候，我们一定会直接或间接的调用父类的构造器，进而调用父类的父类的构造器，知道调用了 <code>Object</code> 的空参构造器为止。正因为加载过所有父类的结构，所以才可以在内存中看到父类的结构，子类对象才可以调用。</li>
<li>虽然创建子类对象时调用了父类构造器，但是自始至终只创建了一个对象，即子类对象<br />
<img src="media/16221979238015/16222740581782.jpg" alt="" class="mw_img_center" style="width:368px;display: block; clear:both; margin: 0 auto;" /></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221963348622.html">5. this & super</a></h1>
			<p class="meta"><time datetime="2021-05-28T18:05:34+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#this">this</a>
<ul>
<li><a href="#%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">调用属性方法</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8">调用构造器</a></li>
</ul>
</li>
<li><a href="#super">super</a>
<ul>
<li><a href="#%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">调用属性方法</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8">调用构造器</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="this" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this</h2>
<h3><a id="%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用属性方法</h3>
<ul>
<li><code>this</code> 表示当前对象或正在创建的对象</li>
<li>当形参与成员变量重名时, 如果在方法内部需要使用成员变量, 必须添加 <code>this</code> 来表明该变量时类成员, 无论是否同名, 都建议添加 <code>this</code> , 增强程序的阅读性</li>
</ul>
<h3><a id="%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用构造器</h3>
<ul>
<li>在构造器中使用 <code>this(形参列表)</code> 显式的调用本类中重载的其它的构造器时必须写在构造器的首行</li>
<li>多个构造器使用 <code>this</code> 调用时, 调用关系不能形成环</li>
</ul>
<pre><code class="language-java">class Person{
	private String name;
	private int age;
	
	public Person(){
		this.name = &quot;AA&quot;;
		this.age = 1;
	}
	
	public Person(String name){
		this();
		this.name = name;
	}
	public Person(String name, int age){
		this(name);
		this.age = age;
	}
	// ...
}
</code></pre>
<h2><a id="super" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>super</h2>
<h3><a id="%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用属性方法</h3>
<ul>
<li>显式的调用父类的指定属性或方法。尤其是当子类与父类有同名的属性、或方法时</li>
</ul>
<h3><a id="%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用构造器</h3>
<ul>
<li><strong>任何一个类 (除 <code>Object</code> 类) 的构造器的首行，要么显式的调用本类中重载的其它的构造器 <code>this(形参列表)</code> 或显式的调用父类中指定的构造器 <code>super(形参列表)</code>, 要么默认的调用父类空参的构造器 <code>super()</code></strong></li>
<li>建议在设计类时，提供一个空参的构造器</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221931135705.html">2. 封装</a></h1>
			<p class="meta"><time datetime="2021-05-28T17:11:53+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F">封装与隐藏</a></li>
<li><a href="#%E4%BD%93%E7%8E%B0">体现</a></li>
<li><a href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6">权限修饰符</a></li>
<li><a href="#javabean">JavaBean</a></li>
</ul>
</div>
<h2><a id="%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>封装与隐藏</h2>
<p>当创建了类的对象以后，如果直接通过 &quot;对象.属性&quot; 的方式对相应的对象属性赋值的话，可能会出现不满足实际情况的意外（例如年龄被设置成负数）。<br />
我们考虑不让对象来直接作用属性，而是通过 &quot;对象.方法&quot; 的形式，来控制对象对属性的访问。</p>
<h2><a id="%E4%BD%93%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>体现</h2>
<ul>
<li>将成员变量权限设置成 <code>private</code>，提供公共的方法 <code>getter setter</code> 调用</li>
</ul>
<h2><a id="%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限修饰符</h2>
<p><img src="media/16221931135705/16221940741269.jpg" alt="" style="width:678px;" /></p>
<p>类只可以用 <code>public</code> 和 <code>缺省</code> 修饰<br />
属性、方法、构造器、内部类可以用上述四种修饰</p>
<h2><a id="javabean" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JavaBean</h2>
<p>用户可以使用 JavaBean 将功能、处理、值、数据库访问和其他任何可以用 Java 创建的对象进行打包, 提供了一种随时随地的复制和粘贴功能, 而不用关心任何改变<br />
JavaBean 是符合如下标准的 Java 类 :</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共构造器</li>
<li>有属性, 且有对应的 get set 方法</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16221841137768.html">1. Class</a></h1>
			<p class="meta"><time datetime="2021-05-28T14:41:53+08:00" 
			pubdate data-updated="true">2021/05/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E7%B1%BB%E6%BA%90%E6%96%87%E4%BB%B6">类 &amp; 源文件</a></li>
<li><a href="#%E6%9E%84%E6%88%90">构成</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7field">属性 (field)</a></li>
<li><a href="#%E6%96%B9%E6%B3%95method">方法 (method)</a>
<ul>
<li><a href="#%E5%80%BC%E4%BC%A0%E9%80%92">值传递</a></li>
<li><a href="#%E9%87%8D%E8%BD%BDoverload">重载 (overload)</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">可变个数的参数</a></li>
</ul>
</li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%99%A8construction">构造器 (construction)</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97">代码块 (初始化块)</a></li>
<li><a href="#%E5%86%85%E9%83%A8%E7%B1%BB">内部类</a></li>
</ul>
</div>
<h2><a id="%E7%B1%BB%E6%BA%90%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类 &amp; 源文件</h2>
<ul>
<li>一个源文件中最多只能有一个 <code>public</code> 类, 其它类的个数不限</li>
<li>如果源文件包含一个 <code>public</code> 类，则文件名必须按该类名命名</li>
</ul>
<h2><a id="%E6%9E%84%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构成</h2>
<ul>
<li><code>field</code> ( 属性 / 成员变量 / 域 / 字段 ): 存在于堆空间中</li>
<li><code>method</code> ( 方法 / 成员方法 / 函数 )</li>
<li><code>construction</code> ( 构造器 )</li>
<li>代码块</li>
<li>内部类</li>
</ul>
<h2><a id="%E5%B1%9E%E6%80%A7field" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>属性 (field)</h2>
<p>属性 &amp; 局部变量</p>
<ul>
<li>相同点
<ul>
<li>声明的格式</li>
<li>先声明, 后使用</li>
<li>都有对应的作用域</li>
</ul>
</li>
<li>不同点
<ul>
<li>声明位置不同: 成员变量声明在类内; 局部变量声明在形参或方法, 代码块, 构造器内部</li>
<li>是否有权限: 属性声明时可以指定权限: <code>private</code> <code>public</code> <code>defalut</code> <code>protected</code></li>
<li>初始化值: 属性根据类型都有默认初始化值; 局部变量调用前一定要显式赋值</li>
<li>内存位置: 属性在堆空间; 局部变量在栈空间</li>
</ul>
</li>
</ul>
<h2><a id="%E6%96%B9%E6%B3%95method" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法 (method)</h2>
<pre><code class="language-java">权限修饰符 [static final abstract] 返回值类型 方法名([形参]){
    // ......
}
</code></pre>
<h3><a id="%E5%80%BC%E4%BC%A0%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>值传递</h3>
<p>Java 中的参数传递机制: 值传递机制</p>
<ul>
<li>形参是基本数据类型: 传递的是变量保存的数据值</li>
<li>形参是引用数据类型: 传递的是变量保存的数据的地址值</li>
</ul>
<h3><a id="%E9%87%8D%E8%BD%BDoverload" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重载 (overload)</h3>
<p>同一个类中, 存在<strong>同名</strong>的方法, 但是参数的类型, 数量, 顺序可以不同, 跟权限修饰符, 返回值都没关系</p>
<pre><code class="language-java">public int getSum(int i, int j) {}
public int getSum(int i, int j, int k) {}
public double getSum(double d1, double d2) {}
public void getSum(double d1, double d2, double d3) {}
public void getSum(int ... is) {}
</code></pre>
<h3><a id="%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可变个数的参数</h3>
<p>格式</p>
<pre><code class="language-java">public void show(int ... is) { // 可变个数的参数必须声明在末尾
    // 使用时把 is 看作一个数组
}
</code></pre>
<ul>
<li>调用时, 可以传 0 - n 个参数</li>
<li>匹配不到其他的重载方法时再调用这个方法</li>
</ul>
<h2><a id="%E6%9E%84%E9%80%A0%E5%99%A8construction" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造器 (construction)</h2>
<pre><code class="language-java">权限修饰符 类名(形参) {}
</code></pre>
<ul>
<li>作用: 创建对象, 给对象属性赋值</li>
<li>若不显式声明类的构造器的话, 程序会默认提供一个空参的构造器</li>
<li>一旦显式的定义类的构造器, 那么默认的构造器就不再提供</li>
<li>一个类中定义的多个构造器, 彼此构成重载</li>
</ul>
<h2><a id="%E4%BB%A3%E7%A0%81%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码块 (初始化块)</h2>
<ul>
<li>用于对对象或类属性进行初始化, 代码块的执行早于构造器</li>
<li>只能不修饰或用 <code>static</code> 修饰</li>
<li><a href="16222923817986.html">静态代码块 vs 非静态代码块</a></li>
</ul>
<h2><a id="%E5%86%85%E9%83%A8%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内部类</h2>
<p>一个事物的内部, 还有一个部分需要一个完整的结构进行描述, 这个内部完整的结构又只为外部事物提供服务.<br />
分类: 成员内部类 (静态 非静态), 局部内部类 (方法 构造器 代码块内)</p>
<ul>
<li>
<p>成员内部类:</p>
<ul>
<li>作为一个类, 可以定义属性方法构造器等, 可以被 <code>final</code> <code>abstract</code> 修饰</li>
<li>作为外部类的成员, 可以调用外部类的成员, 可以被 <code>static</code> <code>四种权限</code> 修饰</li>
</ul>
<pre><code class="language-java">class AA {
    String name;
    static class CC { // 静态成员内部类
        String name;
    }
    class BB { // 非静态成员内部类
        String name;
        public void m(String name) {
            System.out.println(name); // 型参 的 name
            System.out.println(this.name); // BB 的 name
            System.out.println(AA.this.name); // AA 的 name
        }
    }

    public void method() {
        class DD { // 局部内部类
        }
    }
}

// 实例化
AA.CC cc = new AA.CC(); // 静态成员内部类实例化
AA.BB bb = new AA().new BB(); // 非静态成员内部类实例化
</code></pre>
</li>
<li>
<p>局部内部类: <a href="16223735897370.html">抽象类和接口的匿名子类的实例化</a> 都属于局部内部类</p>
</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16222825796598.html">包装类</a></h1>
			<p class="meta"><time datetime="2021-05-29T18:02:59+08:00" 
			pubdate data-updated="true">2021/05/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2">相互转换</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB">基本数据类型 --&gt; 包装类</a></li>
<li><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">包装类 --&gt; 基本数据类型</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BBstring">基本数据类型 包装类 --&gt; String</a></li>
<li><a href="#string%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB">String --&gt; 基本数据类型 包装类</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1">自动装箱</a></li>
</ul>
</div>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>chart</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<p>Byte Short Integer Long Float Double 的父类是 Number</p>
<h2><a id="%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相互转换</h2>
<h3><a id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本数据类型 --&gt; 包装类</h3>
<pre><code class="language-java">// 使用构造器: 参数可以是基本数据类型或字符串
Integer i1 = new Integer(10);
Float f1 = new Float(&quot;20.0f&quot;);
Boolean b1 = new Boolean(&quot;true&quot;);
// 自动装箱
Double d1 = 1.9;
</code></pre>
<h3><a id="%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>包装类 --&gt; 基本数据类型</h3>
<pre><code class="language-java">int i2 = i1.intValue(); // 包装类.xxxValue()
float f2 = f1; // 自动拆箱
</code></pre>
<h3><a id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BBstring" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本数据类型 包装类 --&gt; String</h3>
<pre><code class="language-java">int i3 = 1;
Integer i4 = 5;
// String.valueOf(xxx)
String s1 = String.valueOf(i3);
String s2 = String.valueOf(i4);
String s3 = i3 + &quot;&quot;;
</code></pre>
<h3><a id="string%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>String --&gt; 基本数据类型 包装类</h3>
<pre><code class="language-java">int i5 = Integer.parseInt(&quot;123&quot;); // 包装类.parseXxx(String)
float i6 = new Integer(&quot;234&quot;); // 使用包装类的构造器
</code></pre>
<h2><a id="%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动装箱</h2>
<p>使用自动装箱时, 会优先使用内部缓存, 例如 Integer 的 -128 - 127 范围内都是使用的提前 new 好的对象</p>
<pre><code class="language-java">Integer ii1 = new Integer(1);
Integer ii2 = new Integer(2);
System.out.println(ii1 == ii2); // false

Integer ii3 = 1;
Integer ii4 = 1;
System.out.println(ii3 == ii4); // true

Integer ii5 = 128;
Integer ii6 = 128;
System.out.println(ii5 == ii6); // false
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16222795868244.html">Object</a></h1>
			<p class="meta"><time datetime="2021-05-29T17:13:06+08:00" 
			pubdate data-updated="true">2021/05/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a></li>
<li><a href="#equals">equals</a></li>
<li><a href="#tostring">toString</a></li>
</ul>
</div>
<h2><a id="%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用方法</h2>
<pre><code class="language-java">clone()
equals(Object obj)
finalize() // 没有引用指向的对象, jvm 垃圾回收前会调用这个方法, 程序员不主动去调用
getClass() // 获取创建对象的类
hashCode()
toString()
notify() / notifyAll()
wait() / wait(long timeout) / wait(long timeout, int nanos)
</code></pre>
<h2><a id="equals" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>equals</h2>
<p><code>==</code>: 比较的是两个变量在栈中的内容，如果变量时引用类型，栈中保存的时对象地址<br />
<code>equals</code>: <code>Object</code> 类中默认使用的是 <code>==</code>，如果要比较的是引用类型变量指向的堆内存中的对象，需要重写该方法实现具体的比较逻辑</p>
<pre><code class="language-java">public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    
    Person person = (Person) o;
    return age == person.age &amp;&amp; Objects.equals(name, person.name);
}
</code></pre>
<h2><a id="tostring" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toString</h2>
<p>当我们输出一个对象时,实际上是调用的对象的 <code>toString</code> 方法, 需要重写方法, <code>Object</code> 类中默认返回对象的类和地址信息</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16242598041253.html">Java 容器</a></h1>
			<p class="meta"><time datetime="2021-06-21T15:16:44+08:00" 
			pubdate data-updated="true">2021/06/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="https://share.mubu.com/doc/2cOewutiRya">Java 容器</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16272949641201.html">Linux</a></h1>
			<p class="meta"><time datetime="2021-07-26T18:22:44+08:00" 
			pubdate data-updated="true">2021/07/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>du df<br />
chmod<br />
source<br />
vim more cat<br />
grep<br />
ps<br />
ln</p>
<p>网络相关<br />
统计日志相关</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16242597682603.html">操作系统</a></h1>
			<p class="meta"><time datetime="2021-06-21T15:16:08+08:00" 
			pubdate data-updated="true">2021/06/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="https://share.mubu.com/doc/6REifgLCE2a">操作系统</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16296158444559.html">传输层</a></h1>
			<p class="meta"><time datetime="2021-08-22T15:04:04+08:00" 
			pubdate data-updated="true">2021/08/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#udp">UDP</a>
<ul>
<li><a href="#%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">首部格式</a></li>
<li><a href="#%E5%92%8Ctcp%E5%8C%BA%E5%88%AB">和 TCP 区别</a></li>
</ul>
</li>
<li><a href="#tcp">TCP</a>
<ul>
<li><a href="#%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">首部格式</a></li>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">三次握手</a></li>
<li><a href="#mss-mtu">MSS &amp; MTU</a></li>
<li><a href="#syn%E6%94%BB%E5%87%BB">SYN 攻击</a></li>
<li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a>
<ul>
<li><a href="#tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP可靠传输</a>
<ul>
<li><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">超时重传机制</a></li>
<li><a href="#tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP流量控制</a></li>
<li><a href="#tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP滑动窗口</a></li>
<li><a href="#tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E9%92%88%E5%AF%B9%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%A5%E5%A0%B5%EF%BC%8C%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%8E%A5%E5%8F%97%E7%AA%97%E5%8F%A3%E6%BB%A1%E4%BA%86">TCP拥塞控制：针对网络的拥堵，并不一定接受窗口满了</a></li>
<li><a href="#%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">慢开始与拥塞避免</a></li>
<li><a href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">快重传与快恢复</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2><a id="udp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UDP</h2>
<h3><a id="%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>首部格式</h3>
<ul>
<li><code>源端口</code>（16 bit）、<code>目的端口</code>（16 bit）</li>
<li><code>包长度</code>、<code>校验和</code></li>
</ul>
<h3><a id="%E5%92%8Ctcp%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>和 TCP 区别</h3>
<ul>
<li>连接：UDP 不面向连接，传输数据前不需要建立连接</li>
<li>服务对象：UDP 可以一对多、多对多，TCP 只能一对一</li>
<li>可靠性：UDP 尽最大努力交付，不保证可靠，没有保证可靠的一系列机制</li>
<li>分片：TCP 数据如果大于 MSS 限制，需要在传输层进行分片组装；UDP 数据如果大于 MTU 限制，会在 IP 层分片组装</li>
</ul>
<h2><a id="tcp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP</h2>
<h3><a id="%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>首部格式</h3>
<ul>
<li><code>源端口</code>（16 bit）、<code>目的端口</code>（16 bit）</li>
<li><code>序号</code>（32 bit）、<code>确认号</code>（32 bit）：用来解决网络包乱序和丢包的问题</li>
<li><code>控制位</code>
<ul>
<li><code>ACK</code>：为 1 时，确认号才有效，除了最初建立连接时的 SYN 包之外该位必须为 1</li>
<li><code>SYN</code>：为 1 时，表示希望建立连接</li>
<li><code>FIN</code>：为 1 时，表示之后不会再有数据发送，希望断开连接</li>
<li><code>RST</code>：为 1 时，强制断开连接</li>
</ul>
</li>
<li><code>...</code></li>
</ul>
<h3><a id="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三次握手</h3>
<p><strong>1. 握手过程</strong></p>
<ul>
<li>客户端发送请求「SYN 报文」，SYN=1，ACK=0，序号=x，不携带数据</li>
<li>服务端收到后发送「SYN + ACK 报文」，SYN=1，ACK=1，序号=y，确认号=x+1，不携带数据</li>
<li>客户端收到后发出「ACK 报文」，确认号=y+1，序号=x+1，可以携带数据</li>
<li>服务端收到后建立连接<br />
<img src="media/16296158444559/16296209164060.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;" /></li>
</ul>
<p><strong>2. 为什么需要第三次握手？</strong></p>
<ul>
<li>阻止重复历史连接：如果一个「旧的 SYN」比「新的 SYN」报文早到达了服务器，此时服务器返回一个「SYN + ACK」报文，客户端收到后可以根据自身上下文判断出序列号是否过期超时，过期会发送一个「RST」报文给服务器中止。</li>
<li>同步双方初始序列号：序列号关乎着数据传输的可靠，客户端发送初始序列号后，服务端返回 ACK 的同时也是在发送一个服务端的序列号，然后第三次握手时客户端回应 ACK。</li>
</ul>
<p><strong>3. 为什么二次握手和四次握手不行？</strong></p>
<ul>
<li>二次握手：无法防止历史连接的建立，造成资源浪费，也无法同步双方序列号</li>
<li>四次握手：理论上可行，但是二三次可以合并为一步，三次是理论上最少可靠连接建立</li>
</ul>
<h3><a id="mss-mtu" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MSS &amp; MTU</h3>
<p><img src="media/16296158444559/16296229720296.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;" /></p>
<ul>
<li>MTU：IP 层，一个网络包的最大长度</li>
<li>MSS：TCP 层，报文能容纳的「数据」的最大长度</li>
</ul>
<p><strong>1. 为什么 IP 层会分片，还需要 TCP 层根据 MSS 分片？</strong><br />
因为 IP 协议没有超时重传和序列号机制，如果一个 IP 分片丢失，接收方不知道，整个 TCP 报文都需要重传，经过 TCP 层分片后，如果某一片丢失，重发也只是已 MSS 为单位，增加重传效率。</p>
<h3><a id="syn%E6%94%BB%E5%87%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SYN 攻击</h3>
<p>攻击者短时间伪造不同 IP 地址的 SYN 报文，服务器每收到一个 SYN，就要进入 SYN_RCVD 状态，发出「SYN + ACK」报文，但等不到「ACK」应答。久而久之就会占满整个 SYN 接受队列，不能正常提供服务。</p>
<p><strong>1. 如何避免？</strong></p>
<ul>
<li>修改 linux 内核参数，控制队列大小和队列满时的操作</li>
<li>启用 SYN cookie 功能，当 SYN 队列满了以后，后续的 SYN 包不进入 SYN 队列，而是计算一个 cookie 以「SYN + ACK」返回客户端，服务器收到「ACK」后，如果合法直接放入 Accept 队列。</li>
</ul>
<h3><a id="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四次挥手</h3>
<p><strong>1. 过程</strong></p>
<ul>
<li>客户端发送「FIN 报文」，FIN = 1</li>
<li>服务端收到后发出「ACK 报文」，此时进入半关闭状态，服务端能发给客户端，客户端不能发给服务端</li>
<li>服务端把数据发完后需要关闭时，发送「FIN 报文」</li>
<li>客户端收到后发出「ACK」，然后等待 2MSL 后释放连接</li>
<li>服务端收到「ACK」后释放连接</li>
</ul>
<p><strong>2. 为什么需要四次挥手？</strong><br />
发送「FIN 报文」的一方，仅仅表示他的数据发送完了，另一方可能还有未发送完的数据，所以二三步需要分开发送<br />
导致了比连接多一次。</p>
<p><strong>3. time_wait 为什么是 2 MSL？</strong><br />
<code>MSL</code> 是报文最大生存时间，Linux 默认为 30s。网络中可能存在来自于发送方的数据包，被服务器处理后返回，一来一回可能需要消耗 2 MSL 的时间。<br />
就能够确保本连接报文从网络中消失， 不影响下一次连接。<br />
<img src="media/16296158444559/16296242691391.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;" /></p>
<h4><a id="tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP可靠传输</h4>
<h5><a id="%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>超时重传机制</h5>
<p>超时时间 RTO = RTTs + 4*RTTd RTTs是加权平均往返时间，RTTd 是偏差的加权平均值</p>
<h5><a id="tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP流量控制</h5>
<p>通过窗口字段控制对方发送速率</p>
<h5><a id="tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP滑动窗口</h5>
<p>缓存的一部分，告诉对方自己的缓冲区大小，接受窗口只对最后一个按序到达的字节进行确认，发送方通过这个确认的序号可以知道序号之前的字节都已经被接受</p>
<h5><a id="tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E9%92%88%E5%AF%B9%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%A5%E5%A0%B5%EF%BC%8C%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%8E%A5%E5%8F%97%E7%AA%97%E5%8F%A3%E6%BB%A1%E4%BA%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP拥塞控制：针对网络的拥堵，并不一定接受窗口满了</h5>
<h5><a id="%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>慢开始与拥塞避免</h5>
<p>发送数量（拥塞窗口）从1开始，收到确认后数量加倍，发送数量大于一个阈值，进入拥塞避免，每次数量只+1，当出现超时，阈值设为当前发送数量的一半后重新进入慢开始</p>
<h5><a id="%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快重传与快恢复</h5>
<p>接收方每次只对最后一个已收到的有序报文进行确认，例如收到1 2和4，发送2的确认。 发送方如果收到3个重复的ack就认为报文丢失了，此时执行快重传，立即重传下一个报文3。（超时重传和快重传不一样，超时是一定时间没收到确认，快重传是连续收到三次一样的确认） 这种情况知识丢失个别报文，而不是拥塞，因此执行快恢复，阈值设为拥塞窗口的一半，拥塞窗口设为阈值，直接进入拥塞控制</p>
<blockquote>
<p>参考：小林 coding - 图解网络</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16292717470443.html">TCP/IP</a></h1>
			<p class="meta"><time datetime="2021-08-18T15:29:07+08:00" 
			pubdate data-updated="true">2021/08/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"></div>
<table>
<thead>
<tr>
<th>四层模型</th>
<th>作用</th>
<th>常用协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>专注于为用户提供应用功能，不关注数据如何传输</td>
<td>HTTP、FTP、DNS、DHCP、TELNET、SMTP、POP3、IMAP</td>
</tr>
<tr>
<td>传输层</td>
<td>为应用层提供<strong>端到端</strong>（源主机/目的主机）的网络支持</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td><strong>点对点</strong>（主机/路由器），规定了到达对方计算机的路径，并把数据包传送给对方（寻址、路由选择）</td>
<td>IP、ARP、ICMP、VPN、NAT、RIP、OSPF、BGP</td>
</tr>
<tr>
<td>链路层</td>
<td>用来处理链接网络的硬件部分，包括控制操作系统、驱动、网卡等</td>
<td></td>
</tr>
</tbody>
</table>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16242597185221.html">计算机网络</a></h1>
			<p class="meta"><time datetime="2021-06-21T15:15:18+08:00" 
			pubdate data-updated="true">2021/06/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>
<ul>
<li><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9Fdns">域名系统 DNS</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEftp">文件传送协议 FTP</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEdhcp">动态主机配置协议 DHCP</a></li>
<li><a href="#telnet">TELNET</a></li>
<li><a href="#%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE%EF%BC%88tcp%EF%BC%89%EF%BC%9Asmtp%E3%80%81pop3%E3%80%81imap">邮件协议（TCP）：SMTP、POP3、IMAP</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82url%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%886%E6%AD%A5%EF%BC%89">请求url全过程（6步）</a>
<ul>
<li><a href="#dns%E8%A7%A3%E6%9E%90">DNS解析</a></li>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89">TCP连接（三次握手）</a></li>
<li><a href="#%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82">发送HTTP请求</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9Ehttp%E6%8A%A5%E6%96%87">服务器处理请求并返回HTTP报文</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2">浏览器解析渲染页面</a></li>
<li><a href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89">断开连接（四次挥手）</a></li>
</ul>
</li>
<li><a href="#http%E3%80%81https%EF%BC%88%E7%AB%AF%E5%8F%A3%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81%E5%BC%80%E9%94%80%E3%80%81%E8%AF%81%E4%B9%A6%EF%BC%89">Http、Https（端口、加密、开销、证书）</a>
<ul>
<li><a href="#%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">请求过程</a></li>
<li><a href="#get%E3%80%81post">get、post</a></li>
<li><a href="#session%E3%80%81cookie">session、cookie</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>
<ul>
<li><a href="#udp">UDP</a></li>
<li><a href="#tcp">TCP</a>
<ul>
<li><a href="#%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%BA%90%E7%AB%AF%E5%8F%A32%E3%80%81%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A32%E3%80%81%E5%BA%8F%E5%8F%B74%E3%80%81%E7%A1%AE%E8%AE%A4%E5%8F%B74%E3%80%81%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB%E3%80%81ack%E3%80%81syn%E3%80%81fin%E3%80%81%E7%AA%97%E5%8F%A3%EF%BC%89">首部格式（源端口2、目的端口2、序号4、确认号4、数据偏移、ACK、SYN、FIN、窗口）</a></li>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">三次握手</a></li>
<li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a></li>
<li><a href="#tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP可靠传输</a>
<ul>
<li><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">超时重传机制</a></li>
<li><a href="#tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP流量控制</a></li>
<li><a href="#tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP滑动窗口</a></li>
<li><a href="#tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E9%92%88%E5%AF%B9%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%A5%E5%A0%B5%EF%BC%8C%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%8E%A5%E5%8F%97%E7%AA%97%E5%8F%A3%E6%BB%A1%E4%BA%86">TCP拥塞控制：针对网络的拥堵，并不一定接受窗口满了</a></li>
<li><a href="#%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">慢开始与拥塞避免</a></li>
<li><a href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">快重传与快恢复</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>
<ul>
<li><a href="#ip%E5%8D%8F%E8%AE%AE">IP协议</a>
<ul>
<li><a href="#%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">首部格式</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#arp">ARP</a></li>
<li><a href="#icmp">ICMP</a>
<ul>
<li><a href="#ping">ping</a></li>
<li><a href="#traceroute%EF%BC%9A%E7%94%A8%E6%9D%A5%E8%B7%9F%E8%B8%AA%E4%B8%80%E4%B8%AA%E5%88%86%E7%BB%84%E4%BB%8E%E6%BA%90%E7%82%B9%E5%88%B0%E7%BB%88%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84">traceroute：用来跟踪一个分组从源点到终点的路径</a></li>
</ul>
</li>
<li><a href="#vpn">VPN</a></li>
<li><a href="#nat">NAT</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>
<ul>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">路由器选择协议</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91">分组转发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%93%BE%E8%B7%AF%E5%B1%82">链路层</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a></li>
</ul>
</div>
<p><a href="https://share.mubu.com/doc/5aqZZFg1Zia">计算机网络</a></p>
<h2><a id="%E5%BA%94%E7%94%A8%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用层</h2>
<h3><a id="%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9Fdns" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>域名系统 DNS</h3>
<p>分布式数据库，主机-IP服务 大多数使用UDP传输，两种情况使用TCP：响应超过512、区域传送</p>
<h3><a id="%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEftp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件传送协议 FTP</h3>
<p>TCP，需要两个连接（控制连接、数据连接） 数据传输时服务端有主动、被动两种（主动安全、被动方便）</p>
<h3><a id="%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEdhcp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态主机配置协议 DHCP</h3>
<p>自动配置ip（UDP） 过程：</p>
<ol>
<li>客户端给子网所有机器广播discover报文</li>
<li>DHCP服务器收到后返回offer报文</li>
<li>客户端选择某个服务端信息发送request报文</li>
<li>dhcp服务器返回ack，表示客户端可以使用它提供的消息</li>
</ol>
<h3><a id="telnet" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TELNET</h3>
<h3><a id="%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE%EF%BC%88tcp%EF%BC%89%EF%BC%9Asmtp%E3%80%81pop3%E3%80%81imap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>邮件协议（TCP）：SMTP、POP3、IMAP</h3>
<h3><a id="%E8%AF%B7%E6%B1%82url%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%886%E6%AD%A5%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>请求url全过程（6步）</h3>
<h4><a id="dns%E8%A7%A3%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DNS解析</h4>
<p>按照本地 - 根域名服务器 - 顶级域名服务器的顺序请求，直到得到IP地址并把它缓存到本地，供下次查询使用。 优化（DNS缓存）</p>
<h4><a id="tcp%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP连接（三次握手）</h4>
<h4><a id="%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发送HTTP请求</h4>
<p>请求报头和请求主体两个部分 请求报头：请求的方法（GET / POST）、url、协议（http / https / ftp…），返回的信息是否需要缓存，是否发送cookie等。</p>
<h4><a id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9Ehttp%E6%8A%A5%E6%96%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>服务器处理请求并返回HTTP报文</h4>
<p>对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象 包括：状态码,  响应报头 和 响应报文</p>
<h4><a id="%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>浏览器解析渲染页面</h4>
<h4><a id="%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>断开连接（四次挥手）</h4>
<h3><a id="http%E3%80%81https%EF%BC%88%E7%AB%AF%E5%8F%A3%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81%E5%BC%80%E9%94%80%E3%80%81%E8%AF%81%E4%B9%A6%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Http、Https（端口、加密、开销、证书）</h3>
<h4><a id="%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>请求过程</h4>
<h4><a id="get%E3%80%81post" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>get、post</h4>
<h4><a id="session%E3%80%81cookie" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>session、cookie</h4>
<h2><a id="%E4%BC%A0%E8%BE%93%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传输层</h2>
<p>提供进程间逻辑通信，屏蔽底层细节</p>
<h3><a id="udp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UDP</h3>
<p>无连接、尽可能交付、无拥塞控制、面向报文、可多对多： 首部字段8字节（源端口、目的端口、长度、校验和）</p>
<h3><a id="tcp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP</h3>
<h4><a id="%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%BA%90%E7%AB%AF%E5%8F%A32%E3%80%81%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A32%E3%80%81%E5%BA%8F%E5%8F%B74%E3%80%81%E7%A1%AE%E8%AE%A4%E5%8F%B74%E3%80%81%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB%E3%80%81ack%E3%80%81syn%E3%80%81fin%E3%80%81%E7%AA%97%E5%8F%A3%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>首部格式（源端口2、目的端口2、序号4、确认号4、数据偏移、ACK、SYN、FIN、窗口）</h4>
<h4><a id="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三次握手</h4>
<p>A --&gt; B: A发送请求报文，SYN=1，ACK=0，序号=x B收到后发送确认报文，SYN=1，ACK=1，序号=y，确认号=x+1 A收到后发出确认，确认号=y+1，序号=x+1 B收到后建立连接  为什么需要第三次握手：如果第一次发送的报文阻塞了，客户端和服务器另外建立了连接并传输了数据，这是客户端序列号已经不是最初的x了，如果某个时刻服务器收到了最初的请求，给客户端发送了第二次握手，客户端收到这个握手发现报文确认号和现在的序号对不上就不去第三次握手 如果不进行三次握手，就会建立两个连接</p>
<h4><a id="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四次挥手</h4>
<p>（1）A 发送释放报文 FIN=1 （2）B 收到后发出确认，半关闭，B能发给A，A不能发给B （3）B把数据发完后需要关闭时，B发送释放报文 FIN=1 （4）A收到后发出确认，然后等待2msl后释放，B收到A的确认后释放  半关闭原因：服务端可能有未发送完的数据 time_wait原因：确保B能收到A发送的确认报文、同时使得本连接报文从网络中消失，不影响下一次连接</p>
<h4><a id="tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP可靠传输</h4>
<h5><a id="%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>超时重传机制</h5>
<p>超时时间 RTO = RTTs + 4*RTTd RTTs是加权平均往返时间，RTTd 是偏差的加权平均值</p>
<h5><a id="tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP流量控制</h5>
<p>通过窗口字段控制对方发送速率</p>
<h5><a id="tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP滑动窗口</h5>
<p>缓存的一部分，告诉对方自己的缓冲区大小，接受窗口只对最后一个按序到达的字节进行确认，发送方通过这个确认的序号可以知道序号之前的字节都已经被接受</p>
<h5><a id="tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A%E9%92%88%E5%AF%B9%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%A5%E5%A0%B5%EF%BC%8C%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%8E%A5%E5%8F%97%E7%AA%97%E5%8F%A3%E6%BB%A1%E4%BA%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP拥塞控制：针对网络的拥堵，并不一定接受窗口满了</h5>
<h5><a id="%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>慢开始与拥塞避免</h5>
<p>发送数量（拥塞窗口）从1开始，收到确认后数量加倍，发送数量大于一个阈值，进入拥塞避免，每次数量只+1，当出现超时，阈值设为当前发送数量的一半后重新进入慢开始</p>
<h5><a id="%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快重传与快恢复</h5>
<p>接收方每次只对最后一个已收到的有序报文进行确认，例如收到1 2和4，发送2的确认。 发送方如果收到3个重复的ack就认为报文丢失了，此时执行快重传，立即重传下一个报文3。（超时重传和快重传不一样，超时是一定时间没收到确认，快重传是连续收到三次一样的确认） 这种情况知识丢失个别报文，而不是拥塞，因此执行快恢复，阈值设为拥塞窗口的一半，拥塞窗口设为阈值，直接进入拥塞控制</p>
<h2><a id="%E7%BD%91%E7%BB%9C%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络层</h2>
<p>网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>
<h3><a id="ip%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>IP协议</h3>
<h4><a id="%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>首部格式</h4>
<h4><a id="%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分类</h4>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}  A: 8(0....) + 24 B: 16(10....) + 16 C: 24(110....) + 8 D: 1110.... E: 1111....  CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<h3><a id="arp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ARP</h3>
<p>ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 A 通过 B 的 IP 地址在本地ARP缓存查找B到 MAC 地址，没有查到时主机 A 通过广播的方式发送 ARP 请求，主机 B 收到该请求后会发送 ARP 响应给主机 A 告知其 MAC 地址，随后主机 A 向ARP缓存中写入主机 B 的 MAC 地址。</p>
<h3><a id="icmp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ICMP</h3>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 分为差错报告报文、询问报文</p>
<h4><a id="ping" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ping</h4>
<p>发送询问报文（ECHO请求），目的主机返回ECHO回答报文，根据时间和响应次数测试连通性和丢包率</p>
<h4><a id="traceroute%EF%BC%9A%E7%94%A8%E6%9D%A5%E8%B7%9F%E8%B8%AA%E4%B8%80%E4%B8%AA%E5%88%86%E7%BB%84%E4%BB%8E%E6%BA%90%E7%82%B9%E5%88%B0%E7%BB%88%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>traceroute：用来跟踪一个分组从源点到终点的路径</h4>
<p>源主机向目的主机发送第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
<h3><a id="vpn" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>VPN</h3>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 一个内网经过与互联网相连的路由器R1时，把报文加密，再添加一层（互联网与目的内网相连的路由器R2地址），发给路由器R2，再解析出原来的内容，发给目的主机</p>
<h3><a id="nat" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NAT</h3>
<p>以前，NAT 将本地 IP 和全球 IP 一一对应 现在，NAT 使用端口号使得多个专用网内部的主机共用一个全球 IP 地址，也叫做网络地址与端口转换 NAPT</p>
<h3><a id="%E8%B7%AF%E7%94%B1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由器</h3>
<h4><a id="%E8%B7%AF%E7%94%B1%E5%99%A8%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由器选择协议</h4>
<ol>
<li>RIP<br />
每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；每隔一段时间相邻路由器自动交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。 （实现简单、同步速度慢、规模小）</li>
<li>OSPF<br />
链路发生改变时，向所有路由发送链路状态（与哪些路由器相连以及链路的度量）</li>
<li>BGP<br />
每个自治系统都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</li>
</ol>
<h4><a id="%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分组转发</h4>
<ol>
<li>从数据报中提取目的地址和目的网络</li>
<li>是同一网络直接交付，不是统一网络通过路由表查询下一跳路由交付</li>
<li>有默认路由则交给默认路由</li>
</ol>
<h2><a id="%E9%93%BE%E8%B7%AF%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>链路层</h2>
<h2><a id="%E7%89%A9%E7%90%86%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>物理层</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16230575559703.html">HTTP</a></h1>
			<p class="meta"><time datetime="2021-06-07T17:19:15+08:00" 
			pubdate data-updated="true">2021/06/07</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#http%E5%9F%BA%E7%A1%80">HTTP 基础</a>
<ul>
<li><a href="#%E7%8A%B6%E6%80%81%E7%A0%81">状态码</a></li>
<li><a href="#%E5%AD%97%E6%AE%B5">字段</a></li>
</ul>
</li>
<li><a href="#get-post">Get &amp; Post</a></li>
<li><a href="#session-cookie">Session &amp; Cookie</a></li>
<li><a href="#http-https">Http &amp; Https</a>
<ul>
<li><a href="#http%E5%8A%A0%E5%AF%86">Http + 加密</a></li>
<li><a href="#https">Https</a></li>
</ul>
</li>
<li><a href="#http%E7%89%88%E6%9C%AC">HTTP 版本</a>
<ul>
<li><a href="#http1-1">HTTP/1.1</a></li>
<li><a href="#http2-0">HTTP/2.0</a></li>
<li><a href="#http3-0">HTTP/3.0</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="http%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP 基础</h2>
<blockquote>
<p>优点：简单、灵活、跨平台；<br />
缺点：无状态（Cookie 解决）、明文传输不安全（Https 解决）</p>
</blockquote>
<h3><a id="%E7%8A%B6%E6%80%81%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>状态码</h3>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
<th>常见状态吗</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
<td>100 - 继续</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
<td>200 - 有 body<br/>204 - 没有 body<br/>206 - 分块下载时，表示响应的 body 是全部资源的一部分</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
<td>301 - 永久重定向，说明请求的资源不存在了<br/>302 - 临时重定向，资源还在，暂时用另一个 URL 请求<br/>304 - 缓存重定向，不跳转，表示资源未修改，重定向已存在的缓冲文件</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
<td>400 - 客户端请求报文有错，笼统的错误<br/>403 - 服务器禁止访问资源<br/>404 - 请求的资源没有找到</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
<td>500 - 服务器内部错误，笼统的错误<br/>503 - 服务器忙</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%AD%97%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字段</h3>
<p><code>Connection</code>: 为了兼容 1.1 以下 Http 版本，可以使用 <code>Keep-Alive</code> 建立持久连接</p>
<p><code>Host</code>: 指定服务器域名，可以用来访问同一台服务器的不同网站</p>
<p><code>Content-Length</code>: 服务器返回数据的字节长度</p>
<p><code>Accept</code>: 客户端声明自己可以接受的数据格式<br />
<code>Content-Type</code>: 服务器返回数据的类型和编码格式</p>
<p><code>Accpect-Encoding</code>: 客户端能接受的数据压缩方法<br />
<code>Content-Encoding</code>: 服务器返回数据的压缩方法</p>
<h2><a id="get-post" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get &amp; Post</h2>
<ul>
<li>作用：GET 一般用于从服务器获取资源，而 POST 有可能改变服务器上的资源；</li>
<li>安全：GET 只读取，是安全的；POST 会修改服务器内容，是不安全的；</li>
<li>幂等：GET 是幂等的，即读取同一个资源，总是得到相同的数据，POST 不是幂等的；</li>
<li>长度：GET 请求参数在 URL 里，长度有限制；POST 参数在请求体里，无限制。</li>
</ul>
<h2><a id="session-cookie" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Session &amp; Cookie</h2>
<ol>
<li>
<p>什么是 Cookie Session<br />
Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，浏览器发起请求时被携带并发送到服务器上。主要用于以下三个方面：会话状态管理、个性化设置、浏览器行为跟踪。</p>
<p>Session 代表着服务器和客户端一次会话的过程。存储特定用户会话所需的属性及配置信息。当客户算第一次请求时，服务器会生成一个 SessionID 返回给客户端并存储在 Cookie。</p>
</li>
<li>
<p>有什么不同</p>
<ul>
<li>作用范围（浏览器、服务器）</li>
<li>有效期（长时间、会话期间）</li>
<li>存储大小（4K、Session 更大）</li>
<li>安全性</li>
</ul>
</li>
<li>
<p>关联<br />
<img src="media/16230575559703/16230587953656.jpg" alt="" class="mw_img_center" style="width:509px;display: block; clear:both; margin: 0 auto;" /></p>
</li>
<li>
<p>如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转</p>
<ul>
<li>每次请求中都携带一个 SessionID 的参数</li>
<li>Token 机制（类似于 SessionID）</li>
</ul>
</li>
<li>
<p>分布式如何解决 Session 问题</p>
<ul>
<li>使用 Nginx 的 ip_hash 策略：同一 IP 固定 hash 到一个后台服务器</li>
<li>Session 复制</li>
<li>Session 共享（推荐）</li>
</ul>
</li>
</ol>
<h2><a id="http-https" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Http &amp; Https</h2>
<p>参考：<a href="https://segmentfault.com/a/1190000023936425">为什么HTTPS是安全的</a></p>
<p>HTTP 协议中的报文都是以明文的方式进行传输，不做任何加密，容易收到中间人篡改。</p>
<h3><a id="http%E5%8A%A0%E5%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Http + 加密</h3>
<ul>
<li>直接使用 AES 对称加密，传输的密钥也容易被中间人获取，加密形同虚设</li>
<li>如果使用 RSA 非对称加密传输 <code>AES_KEY</code>，也容易被中间人获取公钥，然后对客户端伪装成服务端，对服务端伪装成客户端，从而完成信息篡改</li>
</ul>
<h3><a id="https" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Https</h3>
<p><strong>Https 整体流程如下：</strong></p>
<ol>
<li>客户端给服务器 443 端口发起 Https 请求，同时将自己支持的加密算法发过去（还会携带一个随机数 C）</li>
<li>服务端如果支持客户端的加密算法就将 CA 证书发送给客户端，公钥包含在证书里面（也会携带一个随机数 S）</li>
<li>客户端验证收到的证书，如果合法，就生成一个随机数 <code>per-master key</code>（用来加密之后传输的数据），这个随机数用服务器的公钥加密（只有服务器私钥能解开），同时对之前所有的信息做摘要，供服务器校验。把这两个信息发回服务器</li>
<li>服务器收到后，用私钥解开 <code>per-master key</code>，再比对摘要无误后，对之前所有内容再做个摘要发回客户端校验</li>
<li>如此一来，客户端和服务端都有三个随机数（C、S、per-master），双方用协商好的加密算法，用这<strong>三个随机数生成之后通信用的密钥</strong></li>
</ol>
<p><strong>Https 是如何保证安全的？</strong><br />
CA 机构的公钥是写在操作系统或者浏览器里的，如果是不信任的证书，系统是能够验证的。<br />
假设中间人拦截了第二步服务器发送的证书，如果篡改了证书发给客户端，客户端能够发现；如果不篡改证书直接发回客户端，虽然客户端无法感知有中间人，但是客户端用证书里的公钥加密过的 per-master，中间人没有服务器的私钥是无法解开的，也就算不出最终通信用的密钥。</p>
<p><strong>Https 也不是绝对安全的，使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。</strong></p>
<h2><a id="http%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP 版本</h2>
<h3><a id="http1-1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP/1.1</h3>
<p>改进：</p>
<ul>
<li>默认长链接</li>
<li>使用管道网络传输，只要只要第一个请求发出，不必等待响应就可以发出第二个请求</li>
</ul>
<p>缺点：</p>
<ul>
<li>每次请求都要发送一些重复的未压缩的 Header，只能压缩 Body</li>
<li>会产生对头阻塞：某一个请求服务器处理慢，后面的请求会阻塞</li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端开始，服务器只能响应</li>
</ul>
<h3><a id="http2-0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP/2.0</h3>
<p>改进：</p>
<ul>
<li>头部压缩（HPack）：通信双方共同维护一张头信息表存放头部字段，请求只发送表的字段索引号即可</li>
<li>二进制格式：将文本改成二进制格式的头信息帧和数据帧</li>
<li>多路复用：可以在一个 TCP 连接有多个 Stream 数据流，每个流承载一个请求和回应，在同一个连接内实现并发</li>
<li>服务器推送：服务器可以主动向客户端推送数据</li>
</ul>
<p>缺点：<br />
多个请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住这个连接里所有的请求（1.1 管道传输如果服务器处理慢，后面的请求会阻塞，2.0 是 TCP 传输时阻塞）</p>
<h3><a id="http3-0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP/3.0</h3>
<p>改进：</p>
<ul>
<li>QUIC：把 TCP 改成了基于 UDP 实现的 QUIC，某个流丢包只阻塞这个流，其他流不受影响（同时原先的 TCP 三次握手 + TLS 三次握手共 6 次握手合并成了 3 次握手）</li>
<li>QPack：头部压缩算法 HPack 升级成了 QPack</li>
</ul>
<p>缺点：<br />
很多设备不认识 QUIC，只能当作 UDP，会出现很多问题，普及速度很慢。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Redis.html"><strong>Redis&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%88%86%E5%B8%83%E5%BC%8F.html"><strong>分布式&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A1%86%E6%9E%B6.html"><strong>框架&nbsp;(15)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Netty.html">Netty&nbsp;(10)</a>&nbsp;&nbsp;
	        
	        	<a href="WebService.html">WebService&nbsp;(5)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A0%A1%E6%8B%9B.html"><strong>校招&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Algorithm.html"><strong>Algorithm&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Java.html"><strong>Java&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="JVM.html">JVM&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="JUC.html">JUC&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="JavaSe.html">JavaSe&nbsp;(17)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><strong>操作系统&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"><strong>计算机网络&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="16242598828200.html">数据库</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16261749989563.html">主从 & 哨兵</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16261740670297.html">淘汰策略</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16261737897880.html">与 MemCached 对比</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16261704935337.html">Redis 数据结构</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



  














<style type="text/css">
  
/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript */
/*
 Solarized Color Schemes originally by Ethan Schoonover
 http://ethanschoonover.com/solarized

 Ported for PrismJS by Hector Matos
 Website: https://krakendev.io
 Twitter Handle: https://twitter.com/allonsykraken)
*/

/*
SOLARIZED HEX
--------- -------
base03    #002b36
base02    #073642
base01    #586e75
base00    #657b83
base0     #839496
base1     #93a1a1
base2     #eee8d5
base3     #fdf6e3
yellow    #b58900
orange    #cb4b16
red       #dc322f
magenta   #d33682
violet    #6c71c4
blue      #268bd2
cyan      #2aa198
green     #859900
*/

code[class*="language-"],
pre[class*="language-"] {
  color: #657b83; /* base00 */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  background: #073642; /* base02 */
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  background: #073642; /* base02 */
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
  border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdf6e3; /* base3 */
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #93a1a1; /* base1 */
}

.token.punctuation {
  color: #586e75; /* base01 */
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #268bd2; /* blue */
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.url,
.token.inserted {
  color: #2aa198; /* cyan */
}

.token.entity {
  color: #657b83; /* base00 */
  background: #eee8d5; /* base2 */
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #859900; /* green */
}

.token.function,
.token.class-name {
  color: #b58900; /* yellow */
}

.token.regex,
.token.important,
.token.variable {
  color: #cb4b16; /* orange */
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>